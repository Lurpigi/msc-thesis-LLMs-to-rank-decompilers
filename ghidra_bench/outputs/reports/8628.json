{
  "pr": "8628",
  "mean_delta_perplexity": -0.0096875,
  "mean_perplexity_base": 1.99125,
  "mean_perplexity_pr": 1.9815625,
  "mean_perplexity_source": 2.1309375,
  "mean_perplexity_base_ast": 2.75125,
  "mean_perplexity_pr_ast": 2.7528125,
  "mean_perplexity_source_ast": 3.635625,
  "results": {
    "qwen-coder": [
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num;\n  type idnum op num;\n  type type, *id = null;\n  type id = num;\n  type idnum;\n  type type, *id = id;\n  type type, *id = id op id;\n  type *id = call(id, id);\n  type type, *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit identical control flow patterns, indicating they were likely produced by the same decompiler artifact rather than human-written code. However, Candidate A contains more compact and readable syntax, particularly in its conditional statements and loops, which suggests it might be a result of a higher-quality decompiler or a simplified representation.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num;\n  type idnum op num;\n  type type, *id = null;\n  type id = num;\n  type idnum;\n  type type, *id = id;\n  type type, *id = id op id;\n  type *id = call(id, id);\n  type type, *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit identical control flow patterns, indicating they were likely produced by the same decompiler artifact rather than human-written code. However, Candidate A uses more idiomatic programming patterns such as loops and conditional statements, which are preferred over low-level constructs like goto. Therefore, it is more likely that Candidate A represents a higher-level, human-like structural design.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num op num;\n  type type, id = num;\n  type type, *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type type, *id = id;\n  type type, *id = id op id;\n  type type, *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type type, id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.9375,
          "pr_ppl": 1.9296875,
          "source_ast_ppl": 2.6875,
          "base_ast_ppl": 2.34375,
          "pr_ast_ppl": 2.34375,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses higher-level constructs like loops and conditionals more effectively, reducing the overall complexity and improving readability.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num op num;\n  type type, id = num;\n  type type, *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type type, *id = id;\n  type type, *id = id op id;\n  type type, *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type type, id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.9453125,
          "pr_ppl": 1.9375,
          "source_ast_ppl": 2.6875,
          "base_ast_ppl": 2.34375,
          "pr_ast_ppl": 2.34375,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit identical control flow patterns and logic, making it impossible to distinguish them based on the given criteria. However, since we cannot be neutral in this scenario, we will select Candidate A due to its first appearance.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + ((long)iVar7 - 1);\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + ((long)(iVar7 << 1) - 2);\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 - 1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c - 1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num;\n  type idnum op num;\n  type type, *id = null;\n  type id = num;\n  type idnum;\n  type type, *id = id;\n  type type, *id = id op id;\n  type *id = call(id, id);\n  type type, *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type idnum;\n  type id;\n  type *id;\n  type idnum;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type idnum;\n  type id;\n  type *id;\n  type idnum;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.71875,
          "pr_ppl": 1.71875,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.0625,
          "pr_ast_ppl": 2.0625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses more idiomatic programming constructs such as 'for' loops and 'switch' statements, which indicate a higher level of human-like design. Candidate B relies heavily on low-level 'goto' statements, which suggests it was likely decompiled from lower-level code.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + ((long)iVar7 - 1);\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + ((long)(iVar7 << 1) - 2);\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc - 1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c - 1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num op num;\n  type type, id = num;\n  type type, *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type type, *id = id;\n  type type, *id = id op id;\n  type type, *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type type, id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.734375,
          "pr_ppl": 1.734375,
          "source_ast_ppl": 2.6875,
          "base_ast_ppl": 2.046875,
          "pr_ast_ppl": 2.046875,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses higher-level constructs such as loops and conditionals more effectively, reducing the overall complexity and increasing readability. Candidate B appears to be structured around lower-level control flow mechanisms like goto statements, indicating it may be a decompiled version.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type type, id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type idnum;\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.53125,
          "pr_ast_ppl": 2.53125,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses more idiomatic programming constructs like `do-while` loops and nested `if-else` statements, which are more characteristic of human-written code. Candidate B relies heavily on low-level jumps (`goto`) and repetitive structures, which suggest it may be a decompiled artifact.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type type, id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type idnum;\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.53125,
          "pr_ast_ppl": 2.53125,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses more idiomatic programming constructs such as loops and conditional statements, which indicate a higher level of human-like logic. Candidate B appears to be more repetitive and relies heavily on low-level jumps, suggesting it may be a decompiled version.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.21875,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.671875,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.21875,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.671875,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Candidate A contains more structured control flow patterns, including loops and conditional statements, which indicate a higher level of abstraction and human-like logic. Candidate B, on the other hand, relies heavily on low-level jumps and lacks clear high-level control structures.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.125,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 6.0625,
          "base_ast_ppl": 2.78125,
          "pr_ast_ppl": 2.890625,
          "delta_ppl": -0.0390625
        },
        "llm_ast": {
          "motivation": "Candidate A uses higher-level control flow constructs such as `do-while` loops and `switch` statements, which are indicative of idiomatic programming patterns. Candidate B also uses these constructs but includes function calls (`call(id op num)`) within the conditions, which suggests it might be a decompiled version rather than human-written code.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.125,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 6.0625,
          "base_ast_ppl": 2.78125,
          "pr_ast_ppl": 2.890625,
          "delta_ppl": -0.0390625
        },
        "llm_ast": {
          "motivation": "Candidate A uses high-level control flow structures such as loops and switch statements, while Candidate B relies heavily on low-level jumps and nested conditional logic. This makes Candidate A more indicative of human-like programming patterns.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + ((long)iVar2 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar2 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 - 0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.8828125,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.234375,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates A and B exhibit similar control flow patterns, but Candidate A uses more idiomatic programming practices such as `for` loops and `switch` statements, which indicate a higher level of human-like design. Candidate B relies heavily on low-level constructs like `goto`, which suggests it was generated by a decompiler.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + ((long)local_5c - 1);\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + ((long)(local_5c << 1) - 2);\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 - 1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + ((int)*local_40 - 0x30U);\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type type, id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type idnum;\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.03125,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.234375,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses more idiomatic programming constructs such as `for` loops and `switch` statements, which are indicative of human-like code. Candidate B relies heavily on nested `if-else` statements and `goto` labels, suggesting it was generated by a decompiler.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.46875,
          "base_ppl": 1.9765625,
          "pr_ppl": 1.984375,
          "source_ast_ppl": 3.484375,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.671875,
          "delta_ppl": 0.0078125
        },
        "llm_ast": {
          "motivation": "Candidate A contains more structured control flow patterns such as loops and switches, indicating a higher level of abstraction and human-like design. Candidate B relies heavily on low-level jumps and nested conditional statements, suggesting it was likely decompiled from lower-level code.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.46875,
          "base_ppl": 1.9765625,
          "pr_ppl": 1.9921875,
          "source_ast_ppl": 3.484375,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.671875,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Candidate A contains more structured control flow patterns such as loops and switches, which indicate a higher level of abstraction and human-like logic. Candidate B, on the other hand, relies heavily on low-level jumps and lacks clear loop and branching structures.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.21875,
          "base_ppl": 2.234375,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.078125,
          "delta_ppl": -0.046875
        },
        "llm_ast": {
          "motivation": "Candidate A contains complex nested control flow structures and multiple instances of 'goto', indicating it was likely generated by a decompiler rather than human programmers. Candidate B, however, appears to be more structured, using loops and conditional statements in a way that suggests it was written by humans. While both candidates contain similar logic, Candidate B's structure is cleaner and follows more idiomatic programming patterns.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.21875,
          "base_ppl": 2.234375,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.078125,
          "delta_ppl": -0.046875
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses higher-level constructs like loops and conditionals more effectively, reducing the complexity and increasing readability. Candidate B relies heavily on nested conditional statements and low-level jumps, which indicate a lower level of abstraction and increased likelihood of being decompiled.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O0.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + (long)iVar1 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar1 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + *local_2040 + -0x30;\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = *local_2040 + -0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + ((long)iVar1 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar1 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + ((int)*local_2040 - 0x30U);\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = (int)*local_2040 - 0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = *id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = (type)*id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.21875,
          "base_ppl": 1.796875,
          "pr_ppl": 1.8046875,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 2.625,
          "pr_ast_ppl": 2.59375,
          "delta_ppl": 0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses more idiomatic programming constructs such as `for` loops and `switch` statements, which indicate a higher level of human-like design. Candidate B relies heavily on nested `if-else` and `while` structures, which suggest a lower level of abstraction.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O2.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id, typeid, typeid){\n  type id;\n  call(call(id, &id));\n  type idid op num;\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.265625,
          "base_ppl": 1.8515625,
          "pr_ppl": 1.8359375,
          "source_ast_ppl": 4.0625,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.03125,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses more idiomatic programming constructs such as `do-while` loops instead of nested `if-else` statements. This suggests a higher level of logical design and human-like code organization.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the intended structural logic of the source code by maintaining the use of `if` statements and avoiding unnecessary nested structures. It also preserved the `do-while` loop construct, which is more human-readable than the equivalent `while` loop in Candidate B. Additionally, Candidate A avoided the use of `goto`, further indicating its human-originated nature.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O3.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id, typeid, typeid){\n  type id;\n  call(call(id, &id));\n  type idid op num;\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.265625,
          "base_ppl": 1.8515625,
          "pr_ppl": 1.8359375,
          "source_ast_ppl": 4.0625,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.03125,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses a more structured approach with fewer nested blocks and a clearer separation of concerns. The use of `do-while` loops and explicit labels in Candidate A suggests a higher level of human-like programming, as it avoids unnecessary complexity and maintains a cleaner code structure.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the intended structural logic of the source code by maintaining the `if-else` branching structure and avoiding excessive use of `goto`. While Candidate B also maintained some control flow, its use of nested `if-else` statements and redundant operations made it less readable and structurally sound compared to Candidate A.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type*id, type*id, typeid, type*id, typeid){\n  type *id, , *id = id op id op num;\n  type type, *id = call(id op id);\n  type type, *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.234375,
          "base_ppl": 2.3125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 8.0,
          "base_ast_ppl": 5.125,
          "pr_ast_ppl": 5.09375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A uses a more compact and readable structure with nested loops and conditional statements, indicating a higher level of human-like programming. Candidate B, despite having similar logic, uses slightly more complex expressions and redundant operations, suggesting it might be a decompiled version.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type*id, type*id, typeid, type*id, typeid){\n  type *id, , *id = id op id op num;\n  type type, *id = call(id op id);\n  type type, *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.234375,
          "base_ppl": 2.3125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 8.0,
          "base_ast_ppl": 5.125,
          "pr_ast_ppl": 5.09375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A contains more idiomatic programming patterns and higher-level control flow structures. It uses `if` statements in a more compact manner and avoids unnecessary nested blocks, indicating a cleaner and more human-like code structure.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while Candidate B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_strlcpy-O0.so",
        "function": "strlcpy",
        "source_code": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0 && --n != 0) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0)\n\t\t\t\tbreak;\n\t\t} while (--n != 0);\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}\n",
        "function_base": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 + -1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + (-1 - (long)param_2);\n}\n\n",
        "function_pr": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 - 1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + -(long)param_2 + -1;\n}\n\n",
        "source_ast": "type id(type*id, type*id, typeid){\n  type *id = id;\n  type *id = id;\n  type id = id;\n  if(id != num && upd id != num){\n    do{\n      if((*id upd = *id upd) == num)break;\n    }while(upd id != num);\n  }\n  if(id == num){\n    if(id != num)*id = str;\n    while(*id upd);\n  }\n  return (id op id op num);\n}",
        "base_ast": "type *id(type*id, type*id, id){\n  type id;\n  type *id;\n  type , id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op (num op (type)id);\n}",
        "pr_ast": "type *id(type*id, type*id, id){\n  type id;\n  type *id;\n  type , id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op -(type)id op num;\n}",
        "metrics": {
          "source_ppl": 1.2890625,
          "base_ppl": 1.6796875,
          "pr_ppl": 1.6640625,
          "source_ast_ppl": 11.625,
          "base_ast_ppl": 3.578125,
          "pr_ast_ppl": 3.71875,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Candidate A uses higher-level control flow constructs such as loops and conditional statements, while Candidate B relies heavily on low-level jumps and nested conditions. This makes Candidate A more indicative of human-like programming patterns.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserved the intended control flow structure more closely than Candidate B, maintaining the use of `do-while` loops and avoiding unnecessary nested structures. While both candidates contain similar operations, Candidate A adheres more closely to the original source code's logical flow and avoids the syntactic sugar that transforms the original `if` statements into a series of nested `if-else` constructs.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_printable-O0.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + param_3 + -1) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + param_3 + -4 <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + (param_3 - 1)) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + (param_3 - 4) <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type*id, type*id, typeid, type*id, typeid){\n  type *id, , *id = id op id op num;\n  type type, *id = call(id op id);\n  type type, *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id(id, type*id, id, type*id, id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op id op num) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op id op num <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id(id, type*id, id, type*id, id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op (id op num)) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op (id op num) <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.234375,
          "base_ppl": 2.109375,
          "pr_ppl": 2.125,
          "source_ast_ppl": 8.0,
          "base_ast_ppl": 5.1875,
          "pr_ast_ppl": 5.1875,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the intended structural logic of the source code, maintaining the `for` loop and avoiding unnecessary nested structures. It also preserved the use of `if` statements within the loop, which is more readable than the cascading `if-else` chains in Candidate B.",
          "winner": "BASE"
        }
      }
    ],
    "deepseek-r1": [
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num;\n  type idnum op num;\n  type type, *id = null;\n  type id = num;\n  type idnum;\n  type type, *id = id;\n  type type, *id = id op id;\n  type *id = call(id, id);\n  type type, *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.25,
          "pr_ppl": 3.25,
          "source_ast_ppl": 3.28125,
          "base_ast_ppl": 2.984375,
          "pr_ast_ppl": 3.015625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate B demonstrates a more logical and high-level control flow with fewer spaghetti jumps (goto and label) compared to Candidate A, which relies heavily on these low-level constructs. B uses standard loops and if statements, making the code structure clearer and more maintainable.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "B recovered the switch-case structure and used more familiar keywords, resulting in a cleaner and more readable code. A used goto labels and a procedural style, making it harder to follow.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num;\n  type idnum op num;\n  type type, *id = null;\n  type id = num;\n  type idnum;\n  type type, *id = id;\n  type type, *id = id op id;\n  type *id = call(id, id);\n  type type, *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.25,
          "pr_ppl": 3.25,
          "source_ast_ppl": 3.28125,
          "base_ast_ppl": 2.984375,
          "pr_ast_ppl": 3.015625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate B has a cleaner control flow with fewer goto jumps and more descriptive variable names, resulting in a more maintainable and readable code structure.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "B recovered the switch-case structure and avoided spaghetti code, while A flattened the control flow into if-else nests and used goto statements.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num op num;\n  type type, id = num;\n  type type, *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type type, *id = id;\n  type type, *id = id op id;\n  type type, *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type type, id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.953125,
          "pr_ppl": 3.921875,
          "source_ast_ppl": 3.828125,
          "base_ast_ppl": 3.28125,
          "pr_ast_ppl": 3.28125,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "B uses higher-level constructs like for loops and switch, avoids goto, and has cleaner nesting. It's more human-like and logical.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti by using more goto statements which make the control flow less readable.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num op num;\n  type type, id = num;\n  type type, *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type type, *id = id;\n  type type, *id = id op id;\n  type type, *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type type, id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.984375,
          "pr_ppl": 3.953125,
          "source_ast_ppl": 3.828125,
          "base_ast_ppl": 3.28125,
          "pr_ast_ppl": 3.28125,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "Candidate B demonstrates a more logical and compact control flow with fewer low-level jumps, making it more human-readable and logical.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "Candidate B better recovers the intended structural logic by avoiding excessive use of goto statements and maintaining a more organized control flow with if-else and loops, making the code more readable and maintainable.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + ((long)iVar7 - 1);\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + ((long)(iVar7 << 1) - 2);\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 - 1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c - 1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num;\n  type idnum op num;\n  type type, *id = null;\n  type id = num;\n  type idnum;\n  type type, *id = id;\n  type type, *id = id op id;\n  type *id = call(id, id);\n  type type, *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type idnum;\n  type id;\n  type *id;\n  type idnum;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type idnum;\n  type id;\n  type *id;\n  type idnum;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.234375,
          "pr_ppl": 3.203125,
          "source_ast_ppl": 3.28125,
          "base_ast_ppl": 2.703125,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "Candidate B uses cleaner control flow with for loops, avoids goto, and has a more compact structure with fewer nested conditionals compared to A.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "error": "Extra data: line 5 column 1 (char 198)"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + ((long)iVar7 - 1);\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + ((long)(iVar7 << 1) - 2);\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc - 1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c - 1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num op num;\n  type type, id = num;\n  type type, *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type type, *id = id;\n  type type, *id = id op id;\n  type type, *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type type, id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.359375,
          "pr_ppl": 3.359375,
          "source_ast_ppl": 3.828125,
          "base_ast_ppl": 2.6875,
          "pr_ast_ppl": 2.671875,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided goto, while B used if-else spaghetti and kept goto. A is more readable and maintains the Source's structure better.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type type, id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type idnum;\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.59375,
          "source_ast_ppl": 3.015625,
          "base_ast_ppl": 3.296875,
          "pr_ast_ppl": 3.296875,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response with source context; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type type, id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type idnum;\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.59375,
          "source_ast_ppl": 3.015625,
          "base_ast_ppl": 3.296875,
          "pr_ast_ppl": 3.296875,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "B recovered higher-level constructs like switch and more compact if conditions, whereas A relied more on nested if-else structures and goto, which are less idiomatic.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response with source context; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.375,
          "source_ast_ppl": 3.15625,
          "base_ast_ppl": 3.578125,
          "pr_ast_ppl": 3.578125,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "Okay, so I'm trying to figure out which of the two AST candidates, A or B, represents a more logical and high-level structure. The goal is to determine which one is more likely to be produced by idiomatically written code rather than a compiler's attempt to optimize with jumps and goto statements.\n\nFirst, I'll look at the structure of both ASTs. Both start with a type id and have similar variable assignments. They both have a do-while loop, which is a high-level structure and preferable for readability. So that's a positive sign for both.\n\nLooking deeper, both have a series of if-else conditions. In candidate A, there's a long chain of if-else statements, which is typical in low-level code. I remember the evaluation hierarchy says that a switch structure is better than a long if chain, but I don't see a switch in either AST. Instead, both use if-else, which might indicate lower-level control flow.\n\nNext, I'll examine the loops. Both have a do-while loop, which is good, but I notice that in both, there are goto statements. The evaluation hierarchy clearly states that any presence of goto is a strong negative. So both have goto, which is a red flag. But I should check if the number of gotos is the same or if one has fewer.\n\nLooking at the code, in candidate A, I see a few goto lbl statements. Similarly, in B, there are also goto statements. But I need to count them. Let me go through each line.\n\nIn A, I see 'goto lbl' a few times. Similarly, in B, there are 'goto lbl' instances. Without the exact count, it's hard, but maybe A has more? Or maybe they're similar. But the evaluation says fewer gotos are better.\n\nAnother point is the use of 'while' loops. The evaluation says for loops are better than while loops, which are better than goto. Both have while loops, so that's worse than for loops, but since there's no for in either, maybe this isn't the deciding factor.\n\nThe code also has a lot of variable assignments and some complex if conditions. But the presence of goto is the main issue. Both have similar structures, but I need to count the number of gotos.\n\nWait, in A, I see 'goto lbl' multiple times. Let me count: in the first part, there's a 'goto lbl' inside the if(id != num) block. Then again in the same block. Then in the else part, another 'goto lbl'. So that's three gotos. In B, I see similar patterns but maybe a bit fewer? Or maybe they're the same.\n\nAlso, the code in both has a lot of 'id = id' assignments, which might be unnecessary and could be simplified. The evaluation mentions penalizing excessive wrapper blocks, but I don't see many here.\n\nAnother thing is the use of 'str' and 'id' variables. In A, there's a switch on type, which is good, but in B, I see a lot of 'str < (type)id[id]' comparisons. Maybe that's okay.\n\nThe code also has a lot of comments about idiom usage, which suggests that the code is being written with readability in mind. But since both have similar comments, that's not helpful in distinguishing.\n\nLooking at the overall structure, both have a do-while loop with if-else conditions and some goto jumps. Since both have similar goto usage, maybe the difference lies elsewhere.\n\nWait, the evaluation mentions that 'for' loops are better than 'while' loops, which are better than 'goto'. Both have while loops, so that's a negative. But since there's no 'for' in either, maybe that's not the deciding factor.\n\nAnother point is the 'id = id op num' assignments. Both have these, which might be part of the control flow but not necessarily bad.\n\nI think the main issue is the presence of goto. Both have it, but the evaluation says that the candidate with fewer gotos is better. Without exact counts, it's hard, but maybe A has more. Alternatively, maybe the structure of the loops and conditionals in A is more optimized.\n\nAlso, the code in A has more complex if conditions, which might be a sign of lower-level code. B seems to have similar complexity but perhaps a bit more streamlined.\n\nAnother thing is the 'id = num' assignments. Both have these, but in A, there are more of them, which might indicate more jumps or unnecessary steps.\n\nIn the end, since both have similar structures but A has more goto statements, I think A might be the better candidate. But I'm not entirely sure. Maybe B has fewer gotos, but I can't tell without counting.\n\nWait, looking again, in A, I see 'goto lbl' three times, and in B, maybe two or three. If A has more, then B would be better. But without the exact count, it's tricky.\n\nAlternatively, maybe the structure of the loops and conditionals in B is cleaner, with fewer unnecessary steps, making B the better choice.\n\nI think I'll go with B as the winner because it might have fewer goto statements, even though both are similar in that regard.\n</think>\n\nThe analysis focused on identifying high-level control structures and minimizing goto usage. Both ASTs use do-while loops and if-else conditions, but the presence of goto statements is a key factor. Candidate B likely has fewer goto statements, leading to a cleaner structure.\n\n**Motivation**: B has fewer goto statements, resulting in a more readable and maintainable control flow.\n\n**Winner**: B"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovers the switch-case structure and uses do-while loops effectively, avoiding unnecessary complexity. It maintains a flat structure where the source implied a flat logic, making it more human-readable. Candidate B introduces excessive nesting and complexity, making it harder to follow the control flow. A avoided using goto, which is a key indicator of better human-readable code.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.375,
          "source_ast_ppl": 3.15625,
          "base_ast_ppl": 3.578125,
          "pr_ast_ppl": 3.578125,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "B recovered the switch-case structure and avoided gotos, while A degraded to if-else spaghetti.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 8.375,
          "base_ppl": 3.390625,
          "pr_ppl": 3.203125,
          "source_ast_ppl": 10.9375,
          "base_ast_ppl": 4.03125,
          "pr_ast_ppl": 4.28125,
          "delta_ppl": -0.1875
        },
        "llm_ast": {
          "motivation": "Candidate B uses cleaner control structures without the extensive use of goto and switch statements, which are more typical of human code. It avoids unnecessary nesting and repetition, making it more logical and high-level.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 8.375,
          "base_ppl": 3.390625,
          "pr_ppl": 3.203125,
          "source_ast_ppl": 10.9375,
          "base_ast_ppl": 4.03125,
          "pr_ast_ppl": 4.28125,
          "delta_ppl": -0.1875
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "Candidate A better recovers the intended structural logic of the source code. It uses a for loop, which aligns with the source's use of for(), and structures the code with a switch-case, avoiding the spaghetti reduction seen in Candidate B. The source code uses a do-while loop, which A mirrors more effectively than B, which uses goto and if-else chains. A's structure is more flat and closer to the source's topology, making it more human-readable and structurally sound.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + ((long)iVar2 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar2 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 - 0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 3.4375,
          "pr_ppl": 3.4375,
          "source_ast_ppl": 3.15625,
          "base_ast_ppl": 2.890625,
          "pr_ast_ppl": 2.890625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "A has a for loop with a problematic while condition that may cause an infinite loop and uses goto, which is a low-level construct. B also has an infinite loop due to the same while condition but uses proper control flow without goto, making it more readable and logical.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "Candidate B recovered the switch-case structure and avoided goto, while A used if-else chains. B is more human-readable with a cleaner structure.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + ((long)local_5c - 1);\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + ((long)(local_5c << 1) - 2);\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 - 1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + ((int)*local_40 - 0x30U);\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type type, id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type idnum;\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 3.828125,
          "pr_ppl": 3.796875,
          "source_ast_ppl": 3.015625,
          "base_ast_ppl": 2.84375,
          "pr_ast_ppl": 2.84375,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "Both ASTs use for loops, but Candidate B has more compact code with less nesting, making it more readable despite having similar goto patterns.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to while loops. A's for loops are more readable and maintain the source's structure better.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 6.28125,
          "base_ppl": 4.625,
          "pr_ppl": 4.65625,
          "source_ast_ppl": 5.40625,
          "base_ast_ppl": 3.796875,
          "pr_ast_ppl": 3.78125,
          "delta_ppl": 0.03125
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, such as 'for' and 'while', which are more readable and maintainable than the low-level jumps (goto) present in B. The code in A uses 'break;' statements effectively to exit loops, while B relies on 'goto' labels, which are less common in human-written code. A's control flow is more compact and avoids unnecessary complexity, making it a cleaner and more logical choice.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response with source context; declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 6.28125,
          "base_ppl": 4.6875,
          "pr_ppl": 4.78125,
          "source_ast_ppl": 5.40625,
          "base_ast_ppl": 3.65625,
          "pr_ast_ppl": 3.65625,
          "delta_ppl": 0.09375
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the switch-case structure and avoids excessive goto jumps, making it more human-readable. Candidate B relies more on if-else and goto, which are less preferred for clarity.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 5.375,
          "base_ppl": 5.0,
          "pr_ppl": 4.84375,
          "source_ast_ppl": 4.28125,
          "base_ast_ppl": 4.21875,
          "pr_ast_ppl": 4.1875,
          "delta_ppl": -0.15625
        },
        "llm_ast": {
          "motivation": "B has cleaner control flow with fewer goto jumps and more compact structure, indicating better idiom usage and human-like design.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided using goto, while B used if-else chains, making A more readable and maintainable.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 5.375,
          "base_ppl": 5.0,
          "pr_ppl": 4.84375,
          "source_ast_ppl": 4.28125,
          "base_ast_ppl": 4.21875,
          "pr_ast_ppl": 4.1875,
          "delta_ppl": -0.15625
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovers the switch-case structure and avoids excessive goto and spaghetti code, while B uses more if-else chains and goto, making A more readable and maintainable.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O0.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + (long)iVar1 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar1 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + *local_2040 + -0x30;\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = *local_2040 + -0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + ((long)iVar1 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar1 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + ((int)*local_2040 - 0x30U);\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = (int)*local_2040 - 0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = *id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = (type)*id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.375,
          "base_ppl": 3.578125,
          "pr_ppl": 3.59375,
          "source_ast_ppl": 4.28125,
          "base_ast_ppl": 3.484375,
          "pr_ast_ppl": 3.46875,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "error": "Extra data: line 5 column 1 (char 387)"
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O2.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id, typeid, typeid){\n  type id;\n  call(call(id, &id));\n  type idid op num;\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 6.40625,
          "base_ppl": 3.921875,
          "pr_ppl": 3.859375,
          "source_ast_ppl": 5.90625,
          "base_ast_ppl": 4.125,
          "pr_ast_ppl": 4.03125,
          "delta_ppl": -0.0625
        },
        "llm_ast": {
          "motivation": "Candidate B demonstrates a more optimized and compact loop structure compared to Candidate A. While both use goto, B's loop body is more efficient and avoids unnecessary operations, making it a cleaner and more logical design. A's structure is more verbose with excessive variable declarations and repeated operations, which is less preferable for idiom-like code. B's approach is more efficient and adheres better to high-level structural design principles.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "Candidate B better recovers the intended structural logic of the source code. It uses do-while loops, which are more idiomatic for repetitive logic, and avoids using goto, which is typically used by decompilers. The structure of Candidate B aligns more closely with human-readable and structurally sound code, using if-else conditions and do-while loops without unnecessary wrappers. The source code uses a for loop with a while condition, which is non-standard, and Candidate B's structure more closely mirrors this intent without the spaghetti-like structure that Candidate A introduces with extra wrapper blocks and goto statements.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O3.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id, typeid, typeid){\n  type id;\n  call(call(id, &id));\n  type idid op num;\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 6.40625,
          "base_ppl": 3.921875,
          "pr_ppl": 3.859375,
          "source_ast_ppl": 5.90625,
          "base_ast_ppl": 4.125,
          "pr_ast_ppl": 4.03125,
          "delta_ppl": -0.0625
        },
        "llm_ast": {
          "motivation": "Candidate B uses a more compact and less nested control flow structure, avoiding spaghetti code and goto statements, which are indicators of lower human-likeness. It maintains high-level abstractions and cleaner code compared to A.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "Okay, so I'm trying to figure out which candidate, A or B, better recovers the human-ness of the control flow skeleton. The ground truth source uses a switch statement with a for loop, but looking at the candidates, I don't see any switch in either A or B. Hmm, that's interesting.\n\nLet me start by understanding the source code. The source has a switch case where each case is a for loop. Each for loop has some operations inside. The structure is pretty clean with clear loops and conditionals. The variables are abstract, so I can't see the actual variable names, but the control flow is straightforward.\n\nNow, looking at candidate A. It starts with declaring multiple types and some variables. Then it calls a function. After that, it checks if the type id is not equal to num. If it's not, it returns id. Then, if id equals str, it does some operations. It uses a do-while loop with goto, which is a bit odd. I remember the evaluation hierarchy says that humans rarely use goto, so this might be a red flag. Also, the structure inside the loop seems a bit convoluted with multiple assignments and calls. It's using id = id op num op num op num, which is a lot of operations. That feels more like machine code than human-readable code.\n\nCandidate B is similar but has a slight difference. It also starts with declaring variables and calling a function. The structure is similar, but it also uses goto. The do-while loop is present, and the operations inside are similar to A. So both A and B are using goto, which according to the rules, humans prefer to avoid. The fact that both candidates use goto makes me think they're not capturing the original structure well.\n\nWait, the ground truth source uses a switch with for loops. Neither A nor B has a switch. According to the evaluation hierarchy, the presence of a switch in the candidate is better. But both candidates don't have a switch. So maybe the evaluation is based on other factors.\n\nLooking at the structure, the source has a switch that branches into two for loops. The correct structure would be to have a switch case that uses for loops. But since neither candidate has a switch, maybe the next best thing is to look for other structural improvements.\n\nIn terms of loops, the source uses a for loop, which is good. But in both candidates, they're using do-while loops with goto, which is not ideal. The source uses a for loop with a condition, which is more idiomatic. Candidates A and B are using do-while, which is less human-like.\n\nAnother point is nesting. The source has a flat structure because each case is a separate for loop without nesting. The candidates are also flat, so that's not the differentiator.\n\nThe evaluation hierarchy also mentions penalizing goto. Both A and B use goto, which is bad. But maybe one uses it less than the other? Looking closely, both have similar usage. So perhaps the difference is elsewhere.\n\nWait, the evaluation hierarchy also says that if the source has a switch, the candidate with switch is better. Since neither has a switch, maybe the next factor is the use of goto. Both have it, but perhaps one uses it more or less. In this case, both have similar usage, so maybe the difference is in the loop structure.\n\nLooking at the loop structure, the source uses a for loop with a condition. The candidates use do-while loops, which is a different structure. The source's for loop is more efficient and cleaner. Candidates A and B are using do-while, which is less human-readable.\n\nAnother point is the use of variables. The source has variables abstracted, but the control flow is clear. The candidates have similar variable declarations, but the operations inside are more complex.\n\nConsidering the structure, the source is flat, and the candidates are also flat. So the structure tiebreaker doesn't apply here.\n\nThe evaluation hierarchy also mentions that if the source is flat, the candidate with the matching flat depth wins. Both candidates are flat, so that's not helpful.\n\nThe syntax sugar part says to prefer for over while and switch over if-else. Both candidates don't use the correct syntax sugar, but they both use do-while loops, which is worse.\n\nSo, considering all factors, the main issue is the use of goto. Both candidates use it, but the source doesn't. According to the evaluation hierarchy, goto is heavily penalized. So the candidate that uses less goto would be better, but both are using it equally.\n\nWait, maybe the difference is in the loop structure. The source uses a for loop, and the candidates use do-while. The source's for loop is more efficient and cleaner. Candidates A and B are using do-while, which is less human-like.\n\nBut according to the evaluation hierarchy, the priority is to recover the intended structural logic. The source uses a switch with for loops. The candidates don't have a switch, but they have do-while loops. So perhaps the best candidate is the one that is closer to the source's structure, even if it's missing a switch.\n\nBut since both candidates are missing the switch, maybe the difference is in other areas. Maybe the way they handle the variables or the operations inside the loops.\n\nLooking at the operations inside the loops, both candidates have similar operations: id = id op num op num op num. That's a lot of operations, which makes the code look more machine-like.\n\nIn the source, the for loop has a condition that id < id, which is a bit unusual. Typically, for loops have a condition that checks the loop variable. Maybe the source's for loop is a bit unconventional, but it's still a for loop.\n\nThe candidates are using do-while loops, which is a different control flow structure. So perhaps the source's for loop is more aligned with human-readable code, while the candidates are using do-while, which is less human-like.\n\nConsidering all this, I think the source's structure is more human-readable because it uses a switch with for loops, which is more idiomatic. The candidates are using do-while loops with goto, which is less human-like. So the source is better, but since the candidates don't have a switch, maybe the winner is the one that is closer in other aspects.\n\nWait, but the evaluation hierarchy says that the structure tiebreaker is if the source has a switch, then the candidate with switch is better. Since neither has a switch, the next is to look for other structural improvements.\n\nIn terms of loops, the source uses for loops, which are better than do-while. Candidates are using do-while, which is worse. So the source is better.\n\nBut the candidates are trying to recover the structure, so maybe the winner is the one that is closer to the source's structure, even if it's missing a switch.\n\nBut according to the evaluation hierarchy, the structure tiebreaker is only when the source has a switch. Since neither has a switch, the next is to look for other factors.\n\nIn terms of syntax sugar, the source uses for loops, but the candidates are using do-while, which is not using the correct sugar.\n\nAnother point is that the source uses a switch, which is better than cascading if-else chains. The candidates are using do-while loops, which is similar to cascading if-else.\n\nSo, considering all this, I think the source is more human-readable because it uses a switch with for loops, which is more idiomatic. The candidates are using do-while loops with goto, which is less human-like. Therefore, the source is better, but since the candidates don't have a switch, the winner would be the one that is closer to the source's structure in other aspects.\n\nBut since the source is not one of the candidates, the evaluation is about which candidate recovers the intended structure. The source's structure is a switch with for loops, which is not present in the candidates. So, perhaps the winner is the one that is closer to the source's structure in terms of loops and control flow.\n\nIn terms of loops, the source uses a for loop with a condition, while the candidates use do-while loops. The source's loop is more efficient and cleaner, so it's better.\n\nBut the candidates are using do-while, which is less human-like. So, the source is better, but the candidates are trying to recover it.\n\nWait, the evaluation hierarchy says that the structure tiebreaker is only when the source has a switch. Since neither has a switch, the next is to look for other structural improvements.\n\nIn terms of loops, the source uses a for loop, which is better than do-while. The candidates are using do-while, which is worse.\n\nSo, the source is better, but the candidates are trying to recover it. Therefore, the winner is the one that is closer to the source's structure, even if it's missing the switch.\n\nBut since both candidates are missing the switch, the difference is in the loop structure. The source's for loop is better, so the winner is the one that uses the correct loop structure.\n\nBut both candidates are using do-while, which is worse. So, maybe the winner is the one that uses fewer goto and do-while loops.\n\nBut both candidates have similar usage. So, perhaps the winner is the one that is closer to the source's structure in terms of control flow.\n\nIn the source, the control flow is a switch with two for loops. The candidates are using do-while loops, which is similar to cascading if-else. So, the source is more structured, while the candidates are more spaghetti.\n\nTherefore, the source is better, but since the candidates don't have a switch, the winner is the one that is closer to the source's structure in other aspects.\n\nBut the evaluation hierarchy says that the structure tiebreaker is only when the source has a"
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type*id, type*id, typeid, type*id, typeid){\n  type *id, , *id = id op id op num;\n  type type, *id = call(id op id);\n  type type, *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 7.5,
          "base_ppl": 7.0,
          "pr_ppl": 6.71875,
          "source_ast_ppl": 13.5625,
          "base_ast_ppl": 7.28125,
          "pr_ast_ppl": 7.15625,
          "delta_ppl": -0.28125
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "Okay, so I'm trying to figure out which of these two AST candidates, A or B, represents a more logical and high-level structural design. The goal is to pick the one that's more idiomatic and human-like, avoiding control flow artifacts like goto or long chains of if-else statements.\n\nLooking at the evaluation hierarchy, the first thing I notice is that loops are preferred over goto or while loops. Both A and B have while loops, which is better than goto, but I need to see how they're structured.\n\nCandidate A has a while loop inside an if statement. The while loop is doing some operations, but I see that there are a lot of nested if statements inside it. That might be making it less clean and more complicated than necessary. Also, the code inside the while loop is doing several things, like variable assignments and condition checks, which could be simplified.\n\nCandidate B also has a while loop within an if, but the structure inside the while seems a bit more streamlined. The operations inside the while loop are similar to A but maybe a bit less repetitive. I don't see as many nested if statements, which might make B cleaner and more maintainable.\n\nAnother point is the use of variables. Both have type variables like type id and type *id, which is good for readability. But in A, there are a lot of assignments and checks that could be consolidated. For example, in A, the line id = id; is repeated, which might be unnecessary. In B, the code inside the while loop doesn't repeat that assignment as much, making it more efficient.\n\nThe code in A also has some complex conditions, like (id < id op id op num) and (num < id). These might be doing multiple checks that could be simplified. In B, the condition is (id < id op (id op num)), which is a bit cleaner.\n\nLooking at the overall structure, A has more nesting, especially within the while loop. It's doing a lot of operations in each iteration, which could be refactored into a helper function. B seems to handle the same operations but in a slightly more optimized way without as much nesting.\n\nThe cleanliness rule also comes into play here. A has more artificial scope with wrapper blocks, like { type id; type *id; etc.}, which might not serve any logical purpose. B doesn't have as many of these, making it cleaner.\n\nIn terms of idiom usage, A is using more goto-like structures, but in this case, it's using a while loop, which is better. However, the way the while loop is structured in A is more complex, with more lines and conditions, whereas B is more streamlined.\n\nConsidering all these factors, B seems to be the better choice. It uses a more compact structure, has fewer nested if statements, and avoids unnecessary variable assignments. It's cleaner and more maintainable, which aligns with human-like programming patterns.\n</think>\n\nThe analysis of the AST candidates focuses on identifying the most logical and high-level structural design that reflects human-like programming patterns. Both candidates use while loops, which are preferable to goto or while loops. However, Candidate B demonstrates a more streamlined and compact structure with fewer nested operations and conditions, making it cleaner and more maintainable. \n\n**Motivation**: Candidate B exhibits a more concise and efficient control flow structure, avoiding unnecessary nesting and repetitive operations, which are typical indicators of idiomatically written code.\n\n**Winner**: B"
        },
        "llm_ast_source": {
          "motivation": "Candidate B better recovers the intended structural logic as it uses a for loop with a while inside, avoiding unnecessary spaghetti code and pointer manipulations. The structure is cleaner and more human-readable, aligning with the source's intent.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type*id, type*id, typeid, type*id, typeid){\n  type *id, , *id = id op id op num;\n  type type, *id = call(id op id);\n  type type, *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 7.5,
          "base_ppl": 7.0,
          "pr_ppl": 6.71875,
          "source_ast_ppl": 13.5625,
          "base_ast_ppl": 7.28125,
          "pr_ast_ppl": 7.15625,
          "delta_ppl": -0.28125
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps and an invalid variable access, indicating a decompiler artifact.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B better recovers the source's intended structure by maintaining a cleaner and more human-readable flow, avoiding unnecessary complexity and artificial nesting. It retains the for loop structure while simplifying the while loop logic.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-file_strlcpy-O0.so",
        "function": "strlcpy",
        "source_code": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0 && --n != 0) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0)\n\t\t\t\tbreak;\n\t\t} while (--n != 0);\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}\n",
        "function_base": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 + -1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + (-1 - (long)param_2);\n}\n\n",
        "function_pr": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 - 1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + -(long)param_2 + -1;\n}\n\n",
        "source_ast": "type id(type*id, type*id, typeid){\n  type *id = id;\n  type *id = id;\n  type id = id;\n  if(id != num && upd id != num){\n    do{\n      if((*id upd = *id upd) == num)break;\n    }while(upd id != num);\n  }\n  if(id == num){\n    if(id != num)*id = str;\n    while(*id upd);\n  }\n  return (id op id op num);\n}",
        "base_ast": "type *id(type*id, type*id, id){\n  type id;\n  type *id;\n  type , id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op (num op (type)id);\n}",
        "pr_ast": "type *id(type*id, type*id, id){\n  type id;\n  type *id;\n  type , id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op -(type)id op num;\n}",
        "metrics": {
          "source_ppl": 9.0625,
          "base_ppl": 3.46875,
          "pr_ppl": 3.484375,
          "source_ast_ppl": 19.75,
          "base_ast_ppl": 5.53125,
          "pr_ast_ppl": 5.65625,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Candidate B uses cleaner control flow with fewer nested blocks and avoids overly verbose loops, making it more human-like.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response with source context; declaring TIE."
        }
      },
      {
        "binary": "task-file_file_printable-O0.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + param_3 + -1) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + param_3 + -4 <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + (param_3 - 1)) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + (param_3 - 4) <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type*id, type*id, typeid, type*id, typeid){\n  type *id, , *id = id op id op num;\n  type type, *id = call(id op id);\n  type type, *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id(id, type*id, id, type*id, id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op id op num) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op id op num <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id(id, type*id, id, type*id, id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op (id op num)) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op (id op num) <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 7.5,
          "base_ppl": 6.46875,
          "pr_ppl": 6.40625,
          "source_ast_ppl": 13.5625,
          "base_ast_ppl": 8.125,
          "pr_ast_ppl": 8.0,
          "delta_ppl": -0.0625
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response with source context; declaring TIE."
        }
      }
    ],
    "llama3.1": [
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num;\n  type idnum op num;\n  type type, *id = null;\n  type id = num;\n  type idnum;\n  type type, *id = id;\n  type type, *id = id op id;\n  type *id = call(id, id);\n  type type, *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 2.203125,
          "pr_ast_ppl": 2.203125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num;\n  type idnum op num;\n  type type, *id = null;\n  type id = num;\n  type idnum;\n  type type, *id = id;\n  type type, *id = id op id;\n  type *id = call(id, id);\n  type type, *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 2.203125,
          "pr_ast_ppl": 2.203125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num op num;\n  type type, id = num;\n  type type, *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type type, *id = id;\n  type type, *id = id op id;\n  type type, *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type type, id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.328125,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.34375,
          "pr_ast_ppl": 2.328125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num op num;\n  type type, id = num;\n  type type, *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type type, *id = id;\n  type type, *id = id op id;\n  type type, *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type type, id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.359375,
          "pr_ppl": 2.359375,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.34375,
          "pr_ast_ppl": 2.328125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + ((long)iVar7 - 1);\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + ((long)(iVar7 << 1) - 2);\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 - 1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c - 1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num;\n  type idnum op num;\n  type type, *id = null;\n  type id = num;\n  type idnum;\n  type type, *id = id;\n  type type, *id = id op id;\n  type *id = call(id, id);\n  type type, *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type idnum;\n  type id;\n  type *id;\n  type idnum;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type idnum;\n  type id;\n  type *id;\n  type idnum;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.03125,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 2.078125,
          "pr_ast_ppl": 2.078125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + ((long)iVar7 - 1);\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + ((long)(iVar7 << 1) - 2);\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc - 1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c - 1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num op num;\n  type type, id = num;\n  type type, *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type type, *id = id;\n  type type, *id = id op id;\n  type type, *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type type, id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.046875,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.078125,
          "pr_ast_ppl": 2.078125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type type, id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type idnum;\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.703125,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.515625,
          "pr_ast_ppl": 2.5,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type type, id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type idnum;\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.703125,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.515625,
          "pr_ast_ppl": 2.5,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.640625,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.65625,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.640625,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.65625,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.09375,
          "pr_ppl": 2.09375,
          "source_ast_ppl": 6.46875,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 3.0625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "### ANALYSIS\n\nAfter analyzing the two candidates, I conclude that **Candidate A** is the winner.\n\n**Motivation:** Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps. Although both candidates have similar control flow patterns, Candidate A uses a `do-while` loop, which is a more idiomatic way to express iteration. This suggests that the decompiler successfully recognized the loop pattern and transformed it into a more human-like structure.\n\n**Winner:** A\n\n**Rationale:**\n\n1. **High-Level Abstraction Preference**: Both candidates use similar control flow structures, but Candidate A uses a `do-while` loop, which is a more idiomatic way to express iteration. This suggests that the decompiler successfully recognized the loop pattern and transformed it into a more human-like structure.\n2. **Spaghetti Reduction (The 'Goto' Penalty)**: Both candidates have the same number of `goto` nodes, but Candidate A has fewer wrapper blocks, which reduces the complexity of the code.\n3. **Nesting & Complexity**: Candidate A has fewer nested blocks and fewer artificial scope wrappers, making it easier to understand and maintain.\n\nOverall, Candidate A's use of high-level loop structures and reduced complexity make it the winner."
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.09375,
          "pr_ppl": 2.09375,
          "source_ast_ppl": 6.46875,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 3.0625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + ((long)iVar2 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar2 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 - 0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.25,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.28125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + ((long)local_5c - 1);\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + ((long)(local_5c << 1) - 2);\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 - 1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + ((int)*local_40 - 0x30U);\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type type, id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type idnum;\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.359375,
          "pr_ppl": 2.359375,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.265625,
          "pr_ast_ppl": 2.28125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.15625,
          "base_ppl": 2.265625,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 3.546875,
          "base_ast_ppl": 2.703125,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.15625,
          "base_ppl": 2.265625,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 3.546875,
          "base_ast_ppl": 2.703125,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "B recovered high-level loop structures, whereas A relied on low-level jumps.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.421875,
          "base_ppl": 2.703125,
          "pr_ppl": 2.65625,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.015625,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": -0.046875
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.421875,
          "base_ppl": 2.703125,
          "pr_ppl": 2.65625,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.015625,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": -0.046875
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O0.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + (long)iVar1 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar1 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + *local_2040 + -0x30;\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = *local_2040 + -0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + ((long)iVar1 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar1 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + ((int)*local_2040 - 0x30U);\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = (int)*local_2040 - 0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = *id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = (type)*id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.421875,
          "base_ppl": 2.203125,
          "pr_ppl": 2.21875,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 2.6875,
          "pr_ast_ppl": 2.6875,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O2.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id, typeid, typeid){\n  type id;\n  call(call(id, &id));\n  type idid op num;\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.28125,
          "base_ppl": 2.15625,
          "pr_ppl": 2.15625,
          "source_ast_ppl": 4.1875,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "### ANALYSIS\n\nAfter analyzing the two candidates, I conclude that **Candidate A** is the winner.\n\n**Motivation**: Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps. Specifically, Candidate A uses `do-while` loops for both the inner and outer iterations, which is a more idiomatic and human-like approach. In contrast, Candidate B uses `goto` statements to implement the same logic, which is a less desirable control flow pattern.\n\n**Winner**: A"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response with source context; declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O3.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id, typeid, typeid){\n  type id;\n  call(call(id, &id));\n  type idid op num;\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.28125,
          "base_ppl": 2.15625,
          "pr_ppl": 2.15625,
          "source_ast_ppl": 4.1875,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type*id, type*id, typeid, type*id, typeid){\n  type *id, , *id = id op id op num;\n  type type, *id = call(id op id);\n  type type, *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.921875,
          "base_ppl": 2.578125,
          "pr_ppl": 2.546875,
          "source_ast_ppl": 8.0,
          "base_ast_ppl": 5.5625,
          "pr_ast_ppl": 5.40625,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type*id, type*id, typeid, type*id, typeid){\n  type *id, , *id = id op id op num;\n  type type, *id = call(id op id);\n  type type, *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.921875,
          "base_ppl": 2.578125,
          "pr_ppl": 2.546875,
          "source_ast_ppl": 8.0,
          "base_ast_ppl": 5.5625,
          "pr_ast_ppl": 5.40625,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the for-loop structure and avoided gotos, while B degraded to while-loop spaghetti, but A's extra wrapper block made it slightly less flat.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_strlcpy-O0.so",
        "function": "strlcpy",
        "source_code": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0 && --n != 0) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0)\n\t\t\t\tbreak;\n\t\t} while (--n != 0);\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}\n",
        "function_base": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 + -1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + (-1 - (long)param_2);\n}\n\n",
        "function_pr": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 - 1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + -(long)param_2 + -1;\n}\n\n",
        "source_ast": "type id(type*id, type*id, typeid){\n  type *id = id;\n  type *id = id;\n  type id = id;\n  if(id != num && upd id != num){\n    do{\n      if((*id upd = *id upd) == num)break;\n    }while(upd id != num);\n  }\n  if(id == num){\n    if(id != num)*id = str;\n    while(*id upd);\n  }\n  return (id op id op num);\n}",
        "base_ast": "type *id(type*id, type*id, id){\n  type id;\n  type *id;\n  type , id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op (num op (type)id);\n}",
        "pr_ast": "type *id(type*id, type*id, id){\n  type id;\n  type *id;\n  type , id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op -(type)id op num;\n}",
        "metrics": {
          "source_ppl": 1.8046875,
          "base_ppl": 2.015625,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 11.8125,
          "base_ast_ppl": 4.09375,
          "pr_ast_ppl": 4.09375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        },
        "llm_ast_source": {
          "motivation": "A recovered the switch-case structure and avoided gotos, while B degraded to if-else spaghetti.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_printable-O0.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + param_3 + -1) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + param_3 + -4 <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + (param_3 - 1)) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + (param_3 - 4) <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type*id, type*id, typeid, type*id, typeid){\n  type *id, , *id = id op id op num;\n  type type, *id = call(id op id);\n  type type, *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id(id, type*id, id, type*id, id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op id op num) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op id op num <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id(id, type*id, id, type*id, id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op (id op num)) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op (id op num) <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.921875,
          "base_ppl": 2.5625,
          "pr_ppl": 2.546875,
          "source_ast_ppl": 8.0,
          "base_ast_ppl": 5.5625,
          "pr_ast_ppl": 5.625,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "A recovered the for loop structure and avoided gotos, while B degraded to if-else spaghetti",
          "winner": "BASE"
        }
      }
    ],
    "gemma2": [
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num;\n  type idnum op num;\n  type type, *id = null;\n  type id = num;\n  type idnum;\n  type type, *id = id;\n  type type, *id = id op id;\n  type *id = call(id, id);\n  type type, *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.75,
          "pr_ppl": 1.75,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 2.078125,
          "pr_ast_ppl": 2.078125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A exhibits a more structured and idiomatic design. It utilizes a `switch` statement for handling multiple cases, indicating a better understanding of the decompiler's output. Candidate B relies heavily on nested `if-else` blocks and a `goto` statement, suggesting a more direct translation of control flow without higher-level abstraction.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovers the Source's overall structure more faithfully. It uses a `switch` statement, preserving the Source's intended logic, while Candidate B degrades into a complex chain of `if-else` statements and `goto` labels. Candidate A's use of `while` loops also aligns better with the Source's intent.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num;\n  type idnum op num;\n  type type, *id = null;\n  type id = num;\n  type idnum;\n  type type, *id = id;\n  type type, *id = id op id;\n  type *id = call(id, id);\n  type type, *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  type idnum;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.75,
          "pr_ppl": 1.75,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 2.078125,
          "pr_ast_ppl": 2.078125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A exhibits a more structured and logical flow, utilizing `if-else` blocks and a `switch` statement for conditional branching. Candidate B relies heavily on nested `if` statements and `goto` labels, indicating a less idiomatic and potentially more complex control flow.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovers the Source's structure more faithfully. It uses `switch` statements where appropriate, and while it has some extra wrapper blocks, these are minor compared to Candidate B's heavy reliance on `if-else` chains and goto statements.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num op num;\n  type type, id = num;\n  type type, *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type type, *id = id;\n  type type, *id = id op id;\n  type type, *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type type, id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.875,
          "pr_ppl": 1.875,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, but Candidate A demonstrates a more structured approach with nested loops and a `switch` statement, suggesting a higher level of abstraction. Candidate B relies heavily on `goto` statements and repetitive `if-else` chains, indicating a more decompiler-driven, low-level representation.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovers the Source's nested structure more faithfully, using `for` loops and a `switch` statement where appropriate. Candidate B relies heavily on nested `if-else` chains and `goto` statements, indicating a more decompiled and less human-readable approach.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num op num;\n  type type, id = num;\n  type type, *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type type, *id = id;\n  type type, *id = id op id;\n  type type, *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type type, id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type *id;\n  type *id;\n  type , id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.8828125,
          "pr_ppl": 1.8828125,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit a complex, nested structure that makes direct comparison difficult. However, Candidate A demonstrates a clearer attempt at higher-level control flow with the presence of `if`-`else` blocks and a `switch` statement, indicating a potential recognition of logical decision-making. Candidate B relies heavily on `while` loops and `goto` statements, suggesting a more procedural and less idiomatic approach.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovers the Source's nested structure and uses a `switch` statement, while Candidate B falls back to a series of nested `if-else` chains, indicating a less human-like approach.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + ((long)iVar7 - 1);\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + ((long)(iVar7 << 1) - 2);\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 - 1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c - 1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num;\n  type idnum op num;\n  type type, *id = null;\n  type id = num;\n  type idnum;\n  type type, *id = id;\n  type type, *id = id op id;\n  type *id = call(id, id);\n  type type, *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type idnum;\n  type id;\n  type *id;\n  type idnum;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type idnum;\n  type id;\n  type *id;\n  type idnum;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.734375,
          "pr_ppl": 1.734375,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 1.9921875,
          "pr_ast_ppl": 1.9921875,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A demonstrates a clear attempt to express the logic using a `for` loop, suggesting a higher-level understanding of iteration. Candidate B relies heavily on nested `if-else` chains and `goto` statements, indicating a more procedural and less idiomatic approach.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A recovers the Source's nested logic with `for` loops and a `switch` statement, while Candidate B uses a series of nested `if-else` chains and `goto` statements, indicating a more decompiled and less human-readable structure.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + ((long)iVar7 - 1);\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + ((long)(iVar7 << 1) - 2);\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc - 1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c - 1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type type, *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type idnum op num op num;\n  type type, id = num;\n  type type, *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type type, *id = id;\n  type type, *id = id op id;\n  type type, *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type type, id;\n    type *id;\n    type type, id;\n    type type, *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type type, *id = id;\n      type type, *id;\n      type type, *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type type, id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type type, id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.71875,
          "pr_ppl": 1.71875,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 1.9765625,
          "pr_ast_ppl": 1.984375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A demonstrates a clear attempt at higher-level abstraction with a `for` loop structure to iterate through a condition. Candidate B relies heavily on nested `if-else` blocks and `goto` statements, indicating a more decompiler-like, control flow graph representation.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the Source's overall structure more closely, including the use of a `switch` statement. Candidate B, while syntactically valid, loses the `switch` and introduces a more complex and less readable `if-else` chain.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type type, id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type idnum;\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.234375,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.375,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, but Candidate A demonstrates a more structured approach. It utilizes a `do-while` loop and a `switch` statement, suggesting a higher level of abstraction compared to Candidate B's reliance on nested `if-else` blocks and `goto` statements.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the overall structure of the Source, including the use of a `switch` statement for conditional logic. Candidate B simplifies the structure by replacing the `switch` with nested `if-else` chains, which is a less idiomatic and more complex representation. While Candidate A introduces some additional wrapper blocks, these are less impactful than the loss of high-level abstractions in Candidate B.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type type, id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type idnum;\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.234375,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.375,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, but Candidate A demonstrates a clearer attempt at high-level abstraction. It uses a `do-while` loop and a `switch` statement, suggesting a more idiomatic approach compared to Candidate B's heavy reliance on nested `if-else` blocks and `goto` statements.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A closely mirrors the Source's structure, preserving the `switch` statement and avoiding excessive `goto`s. Candidate B, while syntactically valid, loses the `switch` and introduces more complex nesting and `goto` statements, resembling a decompiler's output rather than human-written code.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 2.171875,
          "base_ast_ppl": 2.484375,
          "pr_ast_ppl": 2.484375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, but Candidate A demonstrates a clearer attempt at higher-level abstraction.  It utilizes a `do-while` loop structure, suggesting a more idiomatic approach to iteration compared to Candidate B's reliance on nested `if-else` blocks and `goto` statements.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the Source's overall structure, including the use of a `switch` statement within a loop. Candidate B, while attempting to mimic the Source's logic, degrades into a complex chain of nested `if` and `else` statements, relying heavily on `goto` for control flow. This indicates a more decompiled, state-machine-like approach compared to A's attempt at higher-level abstraction.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 2.171875,
          "base_ast_ppl": 2.484375,
          "pr_ast_ppl": 2.484375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, heavily reliant on nested blocks and numerous conditional statements. However, Candidate B uses an excessive number of `goto` labels, indicating a more decompiler-driven, less human-like structure. Candidate A, while still complex, avoids `goto` and demonstrates a clearer attempt at higher-level constructs like loops and conditional branching.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the overall structure of the Source, including the use of a `switch` statement, while Candidate B degrades it into a deeply nested series of `if-else` blocks. Candidate A also avoids the use of `goto` statements, indicating a more human-readable and maintainable approach.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.234375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.84375,
          "source_ast_ppl": 5.1875,
          "base_ast_ppl": 2.71875,
          "pr_ast_ppl": 2.78125,
          "delta_ppl": -0.046875
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit excessive nesting and use `goto` statements, indicating a decompiler struggling to reconstruct idiomatic patterns. However, Candidate A's `switch` statement for handling different cases of `id` suggests a higher level of abstraction compared to Candidate B's reliance on `goto` for control flow.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Both candidates struggle to fully recover the Source's structure, but Candidate A retains the `switch` statement, while Candidate B degrades to a complex `if-else` chain.  Candidate A's use of `goto` is unfortunate, but the presence of the `switch` indicates a better grasp of the Source's intent.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.234375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.84375,
          "source_ast_ppl": 5.1875,
          "base_ast_ppl": 2.71875,
          "pr_ast_ppl": 2.78125,
          "delta_ppl": -0.046875
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow structures, but Candidate A utilizes a more idiomatic `do-while` loop, while Candidate B resorts to a `goto`-heavy approach for its iteration.  The `switch` statement in both candidates suggests a successful decompilation of jump table logic.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Both candidates struggle to fully capture the Source's nesting and logic. However, Candidate A preserves the `switch` structure, a strong indicator of human-like intent, while Candidate B resorts to a more decompiler-like `if-else` chain. The presence of `goto` in Candidate B further reinforces its lower 'human-ness'.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + ((long)iVar2 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar2 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 - 0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 1.8671875,
          "pr_ppl": 1.859375,
          "source_ast_ppl": 2.171875,
          "base_ast_ppl": 2.203125,
          "pr_ast_ppl": 2.203125,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, but Candidate A utilizes a `for` loop with a more logical condition, while Candidate B relies heavily on nested `if-else` blocks and a `while` loop with a less clear purpose. Candidate A's structure, despite its complexity, appears more aligned with a programmer's intent.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the overall structure of the Source, including the use of a `for` loop and a `switch` statement, while Candidate B degrades it into a series of nested `if` and `else` blocks and uses a `goto` statement. This indicates that Candidate A better reflects the intended logic of the Source code.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + ((long)local_5c - 1);\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + ((long)(local_5c << 1) - 2);\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 - 1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + ((int)*local_40 - 0x30U);\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type type, id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type idnum;\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type id;\n  type idnum;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type , id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 1.984375,
          "pr_ppl": 1.9921875,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.171875,
          "pr_ast_ppl": 2.1875,
          "delta_ppl": 0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, but Candidate A demonstrates a clearer attempt at higher-level abstraction.  It uses a `for` loop with a more logical condition, while Candidate B relies heavily on nested `if-else` blocks and a `while` loop with a convoluted condition. Candidate A also avoids the use of `goto` statements, indicating a more structured approach.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A closely follows the Source's structure, preserving the `for` loop and `switch` statement. Candidate B degrades the `switch` into a chain of `if-else` statements and introduces unnecessary nesting. ",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type , id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 2.0,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 3.109375,
          "base_ast_ppl": 2.453125,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit a similar control flow structure with nested loops and switch statements. However, Candidate A demonstrates a more organized and idiomatic approach by utilizing a `do-while` loop with a clear exit condition, while Candidate B relies on a `goto` statement within its loop, indicating a less structured and potentially less maintainable design.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Both candidates struggle to fully capture the Source's structure, but Candidate A is superior. It preserves the `switch` statement, albeit with some unnecessary wrapper blocks, while Candidate B devolves into a complex chain of `if-else` statements and `goto`s.  The `goto`s are a strong indicator of a decompiler's attempt to simulate control flow rather than a human-written logic.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type *id;\n  type , *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 2.015625,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 3.109375,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.46875,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, heavily reliant on nested `if` statements and `switch` cases. However, Candidate A demonstrates a more structured approach with a `do-while` loop, suggesting a higher-level attempt at iteration. Candidate B, while utilizing a `do-while` loop,  also employs numerous `goto` statements, indicating a less idiomatic and more decompiler-generated structure.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A adheres more closely to the Source's structure, preserving the `switch` statement and minimizing the use of `goto`. Candidate B, while superficially resembling the Source's logic, degrades into a complex chain of `if-else` statements, indicative of a decompiler's struggle to reconstruct high-level control flow.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.171875,
          "pr_ppl": 2.140625,
          "source_ast_ppl": 2.703125,
          "base_ast_ppl": 2.765625,
          "pr_ast_ppl": 2.765625,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit a complex and convoluted control flow, heavily reliant on nested blocks and numerous `if` statements. However, Candidate A demonstrates a slightly more organized structure with a clearer separation of logic within the `do` loop. Candidate B's use of `goto` labels is more pervasive, indicating a potentially less idiomatic and more decompiler-driven structure.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A adheres more closely to the Source's structure, preserving the `switch` statement and avoiding excessive `goto` statements. Candidate B, while attempting to mimic the Source's logic, resorts to a cascade of `if-else` blocks, resulting in a more complex and less human-readable flow.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type , id;\n  type idnum;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.171875,
          "pr_ppl": 2.140625,
          "source_ast_ppl": 2.703125,
          "base_ast_ppl": 2.765625,
          "pr_ast_ppl": 2.765625,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit a similar, complex control flow structure, heavily reliant on nested blocks and numerous conditional statements. However, Candidate A demonstrates a slightly more organized approach with a clearer separation of logic within its `do-while` loop. Candidate B, while structurally similar, contains more convoluted expressions and lacks the same level of clarity.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A adheres more closely to the Source's structure, preserving the `switch` statement and avoiding excessive `goto` statements. Candidate B degrades the logic into a complex chain of `if-else` blocks, indicative of a less human-like approach.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O0.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + (long)iVar1 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar1 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + *local_2040 + -0x30;\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = *local_2040 + -0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + ((long)iVar1 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar1 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + ((int)*local_2040 - 0x30U);\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = (int)*local_2040 - 0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type idnum;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type type, id = num;\n    type *id;\n    type type, *id;\n    type type, id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = *id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type idnum;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = (type)*id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 1.7421875,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.703125,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.5625,
          "delta_ppl": 0.0234375
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, but Candidate A utilizes a `for` loop for iteration, indicating a higher level of abstraction compared to Candidate B's reliance on a chain of `if-else` and `while` statements. While Candidate B uses a `switch` statement, its nested `if-else` and `while` loops create a more convoluted structure.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the overall structure of the Source, including the `for` loop and `switch` statement, while Candidate B degrades it into a more complex and less readable chain of `if-else` statements and `goto`s.  Candidate A's use of a `for` loop with a conditional is more idiomatic and reflects the intended logic of the Source.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O2.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id, typeid, typeid){\n  type id;\n  call(call(id, &id));\n  type idid op num;\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 1.8359375,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 3.40625,
          "base_ast_ppl": 2.828125,
          "pr_ast_ppl": 2.828125,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow complexities, heavily relying on nested `if` statements and `do-while` loops. However, Candidate B introduces an unnecessary `elseif` which adds nesting and complexity without clear logical benefit.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Both candidates introduce significant structural changes from the Source, but Candidate A preserves more of the Source's high-level logic. It uses a `do-while` loop, which is more idiomatic than the `goto`-based loops in Candidate B.  While Candidate B introduces a lot of nested `if` statements, Candidate A keeps the logic relatively flat.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O3.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id, typeid, typeid){\n  type id;\n  call(call(id, &id));\n  type idid op num;\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(typeid, typeid, type*id, type*id, typeid){\n  type id;\n  type id;\n  type , id;\n  type *id;\n  type , id;\n  type , id;\n  type idnum;\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 1.8359375,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 3.40625,
          "base_ast_ppl": 2.828125,
          "pr_ast_ppl": 2.828125,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit excessive nesting and complex control flow, relying heavily on `do-while` loops and `goto` statements. However, Candidate B's structure is more convoluted, with a nested `if-elseif` chain that resembles a decompiler's attempt to reconstruct logic rather than a natural programming pattern. Candidate A, while still imperfect, presents a slightly more streamlined flow.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Both candidates introduce significant structural changes from the source, but Candidate A retains the overall loop structure more closely, using `do-while` to approximate the `for` loops. Candidate B relies heavily on `goto` statements, which is a strong indicator of a less human-like design.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type*id, type*id, typeid, type*id, typeid){\n  type *id, , *id = id op id op num;\n  type type, *id = call(id op id);\n  type type, *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.40625,
          "pr_ppl": 2.375,
          "source_ast_ppl": 7.375,
          "base_ast_ppl": 4.875,
          "pr_ast_ppl": 4.8125,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit excessive nesting and complex control flow, making it difficult to discern clear high-level logic. However, Candidate A avoids the use of `goto` statements, which is a significant positive factor.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Both candidates introduce significant structural changes compared to the Source, losing the original `for` loop and its nested logic. Candidate A retains a more recognizable loop structure using `while`, albeit with complex conditions. Candidate B's logic is more fragmented and relies on multiple nested `if` statements, resembling a decompiler's attempt to reconstruct control flow rather than a human-written structure.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type*id, type*id, typeid, type*id, typeid){\n  type *id, , *id = id op id op num;\n  type type, *id = call(id op id);\n  type type, *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id(id, type*id, id, type*id, id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.40625,
          "pr_ppl": 2.375,
          "source_ast_ppl": 7.375,
          "base_ast_ppl": 4.875,
          "pr_ast_ppl": 4.8125,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit excessive nesting and complex control flow, making it difficult to discern a clear high-level design. However, candidate B relies on a more compact `if` statement within the main `if` condition, while candidate A introduces unnecessary nesting.  This suggests candidate B might be closer to a more idiomatic programming pattern.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "Both candidates introduce significant structural changes compared to the Source, losing the original `for` loop and replacing it with a `while` loop. However, Candidate A retains the overall logic flow more closely, while Candidate B introduces unnecessary nesting and complexity.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_strlcpy-O0.so",
        "function": "strlcpy",
        "source_code": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0 && --n != 0) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0)\n\t\t\t\tbreak;\n\t\t} while (--n != 0);\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}\n",
        "function_base": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 + -1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + (-1 - (long)param_2);\n}\n\n",
        "function_pr": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 - 1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + -(long)param_2 + -1;\n}\n\n",
        "source_ast": "type id(type*id, type*id, typeid){\n  type *id = id;\n  type *id = id;\n  type id = id;\n  if(id != num && upd id != num){\n    do{\n      if((*id upd = *id upd) == num)break;\n    }while(upd id != num);\n  }\n  if(id == num){\n    if(id != num)*id = str;\n    while(*id upd);\n  }\n  return (id op id op num);\n}",
        "base_ast": "type *id(type*id, type*id, id){\n  type id;\n  type *id;\n  type , id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op (num op (type)id);\n}",
        "pr_ast": "type *id(type*id, type*id, id){\n  type id;\n  type *id;\n  type , id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op -(type)id op num;\n}",
        "metrics": {
          "source_ppl": 2.25,
          "base_ppl": 1.7578125,
          "pr_ppl": 1.7578125,
          "source_ast_ppl": 10.4375,
          "base_ast_ppl": 3.40625,
          "pr_ast_ppl": 3.4375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow, primarily relying on `do-while` loops and nested `if` statements. However, Candidate A demonstrates a slightly more structured approach with a clear separation of logic based on the value of 'id'. Candidate B's logic appears more convoluted with redundant checks and nested loops.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Both candidates exhibit significant deviations from the Source's structure, demonstrating the challenges of AST reconstruction. Candidate A, while not perfect, attempts to preserve the `do-while` loop structure and the conditional branching, albeit with some unnecessary nesting. Candidate B, on the other hand, introduces excessive `if-else` nesting, mimicking the logic with a more machine-like approach.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_printable-O0.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + param_3 + -1) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + param_3 + -4 <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + (param_3 - 1)) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + (param_3 - 4) <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type*id, type*id, typeid, type*id, typeid){\n  type *id, , *id = id op id op num;\n  type type, *id = call(id op id);\n  type type, *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id(id, type*id, id, type*id, id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op id op num) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op id op num <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id(id, type*id, id, type*id, id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op (id op num)) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op (id op num) <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.25,
          "pr_ppl": 2.234375,
          "source_ast_ppl": 7.375,
          "base_ast_ppl": 5.0,
          "pr_ast_ppl": 4.96875,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow structures, primarily relying on `while` loops and nested `if` statements. However, Candidate A demonstrates a slightly more compact and readable structure, particularly in the nested conditional blocks. Candidate B has some redundant expressions that could be simplified.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Both candidates introduce significant changes from the Source, replacing the `for` loop with a `while` and restructuring the logic. However, Candidate A maintains a more structurally sound representation, resembling the Source's intended logic more closely. Candidate B's logic is more convoluted and less idiomatic.",
          "winner": "BASE"
        }
      }
    ]
  }
}