{
  "pr": "8628",
  "mean_delta_perplexity": -0.0071875,
  "mean_perplexity_base": 1.9421875,
  "mean_perplexity_pr": 1.935,
  "mean_perplexity_source": 1.924375,
  "mean_perplexity_base_ast": 2.75125,
  "mean_perplexity_pr_ast": 2.7490625,
  "mean_perplexity_source_ast": 3.67,
  "results": {
    "qwen-3": [
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.34375,
          "base_ppl": 1.859375,
          "pr_ppl": 1.8515625,
          "source_ast_ppl": 2.5,
          "base_ast_ppl": 2.21875,
          "pr_ast_ppl": 2.21875,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more idiomatic arithmetic expressions (e.g., `iVar3 - 1` instead of `iVar3 + -1`), which aligns with natural human-readable code conventions. While the control flow structures remain unchanged, the simplified arithmetic operations in B improve readability without introducing artificial nesting or violating semantic structure principles.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more closely with standard C style by using explicit subtraction (`- 1`) instead of adding a negative value (`+ -1`), which is more idiomatic in source code. The structural isomorphism remains unchanged as the control flow (loops, switches) is unaffected by these arithmetic rewrites.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem. The user wants to determine whether Candidate A or B better matches the Source AST topology based on the given criteria. \n\nFirst, I need to understand the criteria. The first is Topology Match: Does the '+' code (Candidate B) restore a node type present in the Source but missing in Candidate A? The second is Complexity: Does the '+' code match the nesting depth of the Source?\n\nLooking at the provided diff, the only change is in the line:\n\n-        id = id op (type)id op num op num;\n+        id = id op ((type)id op num op num);\n\nSo, the difference is the addition of parentheses around (type)id op num op num in Candidate B. \n\nNow, considering the Source AST. The original code in the Source has various expressions with operators and type casts. The key here is to check if the parentheses in Candidate B match the structure of the Source. \n\nIn the Source, when there's an expression like id op (type)id op num op num, the parentheses might be crucial for the correct operator precedence. If Candidate A is missing those parentheses, then Candidate B adds them, which might align with the original structure. However, the problem states that the Ground Truth (Source) is the one we need to compare against. \n\nBut wait, the Ground Truth is the original code. The diff shows that Candidate A has a line without the extra parentheses, and Candidate B adds them. The question is whether the Source has that structure. Since the Ground Truth is the original code, and the diff is between A and B, perhaps the original code (Source) has the parentheses as in Candidate B. \n\nWait, the user says that the Ground Truth is the Source AST. The diff is between A and B, and we need to see which of A or B matches the Source. So, if the Source has the parentheses, then Candidate B would be the correct one. But how do I know what the Source has here?\n\nLooking back at the Ground Truth provided, the line in question is part of the code. Let me check the Ground Truth code for that specific line. \n\nIn the Ground Truth, looking at the section where the diff is:\n\nIn the Ground Truth, there's a part:\n\n      id = id op id[id];\n      id = id[id];\n      id = id[id];\n      if(id > num){\n        type *id = id;\n        type *id;\n        type *id = id op id op num;\n        while(num){\n          if(id < id)break;\n          id = id op ((id op id) op num);\n          if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n        id = id;\n        id = id;\n      }\n      id = id[id];\n      if(id > num){\n        type *id = id;\n        type *id;\n        type *id = id op (id op num) op num;\n        while(num){\n          if(id < id)break;\n          id = id op (((id op id) op num) op ~num);\n          if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n            id = (type)((id op id) op num);\n            goto lbl;\n          }\n        }\n        id = id;\n      }\n      lbl:\n      id = id[id];\n      id = id[id];\n      if(id[id] == num)goto lbl;\n      id = id op id[id];\n      id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n      lbl:\n      if(id == num)goto lbl;\n      if(upd id != id)goto lbl;\n      lbl:\n      {\n      }\n      if(id == id){\n        type *id = id op id[id];\n        type id = (type)*id upd;\n        while(id upd > num){\n          switch(*id upd){\n            case num:\n            {\n              type *id = call(id, id, id, (id), &id);\n              if(!id){\n                call(id, (id), str, id);\n                if(id->id.id)call(id, id->id);\n              }else{\n                type *id = id;\n                while(id >= id && call(id->id, id) == num){\n                  type *id = id->id[id->id];\n                  call(id->id, (id->id), str, (type)id, id);\n                  id upd;\n                }\n                id = id op num;\n                while(id op id < id && call(id->id, id) == num){\n                  type *id = id->id[id->id];\n                  call(id->id, (id->id), str, (type)id, id);\n                  id upd;\n                }\n              }\n            }\n            break;\n            case num:\n            {\n              call(id, id, id);\n              id[id] = str;\n            }\n            break;\n            case num:\n            {\n              id = id op id;\n            }\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    if(id < num || id != id){\n      if(id->id.id){\n        call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n        call(id, id->id);\n      }\n      id = id;\n    }\n    if(id)call(id);\n    (type)id;\n    return id;\n}\n\nLooking at the part where the diff is, specifically in the Ground Truth code:\n\nIn the section where the diff is, the line in the Ground Truth is:\n\ntype *id = id op (id op num) op num;\n\nWait, in the Ground Truth, the line is:\n\ntype *id = id op (id op num) op num;\n\nBut in the diff, Candidate A has:\n\nid = id op (type)id op num op num;\n\nand Candidate B has:\n\nid = id op ((type)id op num op num);\n\nWait, the diff is in the line:\n\nIn the Ground Truth, the line is:\n\ntype *id = id op (id op num) op num;\n\nBut the diff is about a different line. Wait, the diff provided is:\n\n@@ -76,7 +76,7 @@\n       id = (type)(type)id[id];\n       if(str < (type)id[id]){\n         id = id op id;\n-        id = id op (type)id op num op num;\n+        id = id op ((type)id op num op num);\n         if(id <= id){\n           id = id;\n           do{\n\nSo the line in question in the Ground Truth (Source) would be the line that's in the diff. But since the Ground Truth is the original code, the line in the Source would be the one that's in the diff. However, the diff shows that Candidate A has the line without the extra parentheses, and Candidate B adds them. \n\nBut how do I know which one matches the Source? The problem says that the Ground Truth is the Source AST. Therefore, the original code (Source) must have the structure that's being compared. \n\nAssuming that the Source code has the line as in Candidate B (with the parentheses), then Candidate B would be the correct one. But how can I verify that?\n\nAlternatively, perhaps the parentheses are part of the original code's structure. For example, if the original code had the parentheses, then Candidate B is correct. If the original code didn't, then Candidate A would be correct. \n\nBut since the Ground Truth is the original code, and the diff is between A and B, the user is asking which of A or B matches the Source. Therefore, the line in the Source must be the one that's in the diff. However, the diff shows that Candidate A has the line without the parentheses, and Candidate B adds them. \n\nWait, the diff is showing that in the original code (the Source), the line was as in Candidate A, and Candidate B changed it. But that's not the case. The diff is between A and B, and the user"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.34375,
          "base_ppl": 1.859375,
          "pr_ppl": 1.8515625,
          "source_ast_ppl": 2.5,
          "base_ast_ppl": 2.21875,
          "pr_ast_ppl": 2.21875,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by using direct subtraction (`- 1`) instead of adding a negative value (`+ -1`), which aligns with idiomatic C practices. While the control flow structures remain unchanged, the arithmetic expressions in B are more intuitive and reduce cognitive load for human readers, making the code more human-like in its expression of intent.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more closely with standard C syntax for arithmetic expressions (e.g., using 'iVar3 - 1' instead of 'iVar3 + -1'), which matches the structure of the original source code. The changes are stylistic but preserve equivalent logic without altering control flow structures.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A avoids unnecessary parentheses, maintaining a more concise expression structure. While both versions compute the same logic, Candidate B introduces an artificial grouping with extra parentheses, which may obscure the original intent without improving clarity. The tie-breaker rule favors less artificial nesting when logic is identical.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores the parenthetical grouping present in the Source AST, which structures the expression as a nested operation matching the original topology. The added parentheses in B align with the Source's use of explicit operator precedence through grouping, whereas A's flat structure diverges from this pattern.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.4375,
          "base_ppl": 2.0625,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 2.734375,
          "base_ast_ppl": 2.40625,
          "pr_ast_ppl": 2.40625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more idiomatic arithmetic operators (-1 instead of + -1), which aligns with natural human-readable C code patterns. The logical operations remain identical, but B's formulation avoids the 'additive negation' idiom that feels more mechanical. This follows the hierarchy by prioritizing human-idiomatic expressions over equivalent but less readable alternatives.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more with standard C syntax by using explicit subtraction (-1) instead of adding a negative value (+ -1), which is more consistent with the source code's structural style. The control flow remains unchanged, but the arithmetic expressions in B better match typical C conventions.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A avoids unnecessary parentheses, maintaining a more direct and minimal expression structure. The change in Candidate B introduces an extra layer of parentheses, which could be seen as artificial nesting. Since the logical operation remains identical, Candidate A aligns better with idiomatic design by reducing superfluous syntactic complexity.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores the nested parentheses structure present in the Source AST, which is critical for matching the original topology. The added parentheses in B align with the Source's complex nesting patterns (e.g., `id op ((type)id op num op num)`), whereas Candidate A's flatter structure lacks this depth.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.4375,
          "base_ppl": 2.0625,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 2.734375,
          "base_ast_ppl": 2.40625,
          "pr_ast_ppl": 2.40625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more idiomatic arithmetic expressions (e.g., `iVar12 - 1` instead of `iVar12 + -1`) which aligns with natural human-readable C conventions. While the logic remains identical, B's version avoids the visual noise of negated addition, improving readability without altering control flow structures. The changes do not introduce artificial nesting or degrade semantic clarity.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B uses more idiomatic C arithmetic expressions (e.g., subtraction instead of adding a negative), which aligns better with the source code's structure. The changes are stylistic but maintain structural isomorphism with the original C code's control flow.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + ((long)iVar7 - 1);\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + ((long)(iVar7 << 1) - 2);\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 - 1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c - 1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.34375,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.8125,
          "source_ast_ppl": 2.5,
          "base_ast_ppl": 2.078125,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by grouping arithmetic operations with parentheses, making the intent clearer. Expressions like ((long)iVar7 - 1) are more human-readable than (long)iVar7 + -1, reducing cognitive load when parsing the code. This aligns with semantic structure by avoiding implicit operator precedence ambiguity, which maps better to abstract human logic than raw machine-like arithmetic.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns with the original source structure by using standard C operator precedence and grouping, which matches how expressions would be written in the original code. The changes in B (e.g., `((long)iVar7 - 1)` instead of `(long)iVar7 + -1`) reflect natural C syntax, improving structural isomorphism without altering logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A avoids redundant parentheses, maintaining concise expression structures without artificial nesting. Since the logic is identical, the tie-breaker favors less artificial nesting, aligning with idiomatic design principles that prioritize readability and minimalism.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores parentheses around expressions (e.g., `((type)id op num)`) that align with the Source AST's nested structure. These parentheses indicate explicit operator grouping, which matches the Source's complexity and nesting depth. Candidate A lacks these groupings, diverging from the original topology.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + ((long)iVar7 - 1);\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + ((long)(iVar7 << 1) - 2);\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc - 1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c - 1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.4375,
          "base_ppl": 1.84375,
          "pr_ppl": 1.84375,
          "source_ast_ppl": 2.734375,
          "base_ast_ppl": 2.078125,
          "pr_ast_ppl": 2.078125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more idiomatic arithmetic expressions (e.g., `x - 1` instead of `x + -1`), which aligns with natural human-readable C conventions. The parentheses in B also clarify operator precedence, reducing cognitive load during code review. These changes improve readability without altering logic, making the code more intuitive for human engineers.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more closely with the Source Code structure by reformatting arithmetic expressions to match the source's style (e.g., `a + (b - 1)` instead of `a + b - 1`). The control flow structures (loops, conditionals) remain unchanged, and the modifications are purely syntactic, not introducing new logic errors.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "The structural changes between A and B are limited to expression grouping via parentheses, which do not alter the control flow skeleton (e.g., loops, conditionals). Since the logic is identical, the tie-breaker applies: Candidate A avoids additional parentheses, reducing artificial nesting in the expression tree. This aligns with idiomatic design by favoring minimal, explicit grouping over redundant nesting.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 2.3125,
          "pr_ppl": 2.296875,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.53125,
          "pr_ast_ppl": 2.515625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by using subtraction operators (-) instead of adding negative literals, which aligns with natural human arithmetic expression patterns. The parentheses in B also explicitly group operations, reducing ambiguity compared to A's implicit operator precedence. These changes make the code more intuitive without altering logic flow.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Both versions maintain the same control flow structures (e.g., switches, loops) as the source code. The changes in Candidate B involve reordering arithmetic operations with parentheses, which does not alter the control flow but may better align with the source's intended expression structure. Since no logic errors are introduced and the structural isomorphism remains intact, Candidate B's adjustments are neutral but slightly more syntactically aligned with typical C code conventions.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem. So, the task is to determine whether Candidate A or Candidate B in the diff matches the Source AST topology better based on the given criteria. The Ground Truth is the original source code's AST, and we have to compare the changes between A and B.\n\nFirst, I need to understand what the criteria are. The first one is Topology Match: Does the + code (Candidate B) restore a node type present in the Source but missing in Candidate A? The second is Complexity: Does the + code match the nesting depth of the Source?\n\nLooking at the diff provided, there are two changes. Let me check each one.\n\nThe first change is around line 57. In Candidate A, the line is \"id = id op (type)id op num op num;\" whereas Candidate B changes it to \"id = id op ((type)id op num op num);\". The difference here is the addition of parentheses around (type)id op num op num. The original Source AST might have a specific structure here. If the Source had a certain operator precedence or grouping that's reflected in Candidate B by adding parentheses, then Candidate B would be restoring a node type that was missing in A. But I need to see if the Source's AST has that structure. However, without seeing the actual Source AST structure, I have to infer based on the code.\n\nThe second change is around line 85. In Candidate A, it's \"id = (type)*id op id op num op num;\" and Candidate B changes it to \"id = ((type)*id op id op num) op num;\". Again, adding parentheses here. The question is whether these parentheses correspond to a node type present in the Source but missing in A. If the original code had those parentheses, then B would be adding that structure, which would be a topology match.\n\nBut since I don't have the actual Source AST structure, I need to think about the nesting depth. The second criterion is about complexity and nesting depth. Adding parentheses might change the nesting structure. For example, if the original code had a certain grouping that's represented by the parentheses in B, then B would have the correct nesting depth. However, if the original code didn't have those parentheses, then A might be more accurate.\n\nWait, but the problem says that the Ground Truth is the Source AST. So the diff is between A and B, and we need to see which one aligns with the Source. The Ground Truth is the original code, so the changes in the diff are modifications from the original. But the question is, which version (A or B) mirrors the Source's AST topology. So, perhaps the original Source had the structure that's present in B, and A is missing it. Or vice versa.\n\nBut how can I determine that? The user says that the Ground Truth is the Source AST. So the diff is between two versions (A and B) of the code, and we need to see which one is closer to the original Source.\n\nWait, the problem says that the user is comparing AST changes against the Ground Truth (the Source AST). So the Ground Truth is the original code, and the diff shows changes from A to B. The question is, which of A or B is more like the Source.\n\nBut how do I know which one is closer? The user hasn't provided the actual Source code's AST structure, but the Ground Truth is given as the code block. So the Ground Truth is the original code. Therefore, the diff is between two versions (A and B) that are different from the original. Wait, no. Wait, the Ground Truth is the Source AST. The diff is between two candidates (A and B) that are modified versions of the original. The user wants to know which of A or B is closer to the original Source's AST structure.\n\nBut how can I compare the diff to the original? The original code is the Ground Truth provided. So the diff is between two versions (A and B) that are different from the original. Wait, no. Wait, the diff is between A and B. The original Source is the Ground Truth. So the user is trying to determine which of A or B is more like the original Source's AST.\n\nBut how can I do that without knowing the original AST structure? The Ground Truth is the original code, so the original code's AST structure is the one given. The diff shows changes between A and B. So the user is saying that the original code (Ground Truth) has certain structures, and the diff shows two versions (A and B) that differ from the original. Wait, no. Wait, the problem says that the user is comparing AST changes against the Ground Truth. So the Ground Truth is the original code. The diff is between two versions (A and B) that are modified versions. The user wants to know which of A or B is more like the original.\n\nBut how can I determine that? The diff shows that in Candidate A, certain lines are present, and in Candidate B, they are modified. For example, in the first change, Candidate A has \"id = id op (type)id op num op num;\" while Candidate B adds parentheses around (type)id op num op num. So, the original code (Ground Truth) might have that structure. If the original code had the parentheses, then Candidate B would be the correct one. If the original code didn't have them, then Candidate A would be correct.\n\nBut how can I know? The Ground Truth code is provided. Let me look at the Ground Truth code. The original code has lines like:\n\ntype *id = id op id;\ntype *id = id;\ntype id;\ntype id = num;\n{\n  id = (type)id;\n}\n...\n\nLooking at the first change in the diff, the line in the original code (Ground Truth) would be the one that's in the diff's context. Wait, the diff is between A and B. The original code (Ground Truth) is the one that's being compared. So the user is saying that the Ground Truth is the original code, and the diff is between two versions (A and B) that are different from the original. Wait, no. The problem says that the user is comparing AST changes against the Ground Truth. So the Ground Truth is the original code, and the diff shows changes between A and B. The user wants to know which of A or B is closer to the original.\n\nBut how can I compare the diff to the original? The original code is the Ground Truth. The diff is between A and B. So the original code is not part of the diff. Therefore, the user is trying to determine which of A or B is more like the original code. But how can I know that without seeing the original code's AST structure?\n\nWait, the Ground Truth is the original code. The diff is between two versions (A and B) that are different from the original. So the user is trying to find out which of A or B is closer to the original code's AST structure.\n\nBut how can I determine that? The diff shows the changes between A and B. The original code's AST is the Ground Truth. So the user is asking which of A or B is more like the original code.\n\nBut without knowing the original code's AST structure, how can I compare? Wait, the Ground Truth is the original code. The user is providing the original code as the Ground Truth. So the diff is between two versions (A and B) that are different from the original. Wait, but the diff is between A and B. So the original code is not part of the diff. Therefore, the user is trying to determine which of A or B is more like the original code.\n\nBut how can I do that? The answer must be based on the changes in the diff and the original code's structure. Let me look at the original code's structure.\n\nIn the original code, there are several lines with expressions involving operators. For example, in the original code, there's a line like:\n\ntype *id = id op id;\n\nWhich is a simple operation. Then, in the diff, the first change is in Candidate A: \"id = id op (type)id op num op num;\" versus Candidate B's \"id = id op ((type)id op num op num);\". The difference is the parentheses around (type)id op num op num. The original code might have a certain grouping here. If the original code had parentheses, then Candidate B would be the correct one. If not, then Candidate A.\n\nBut how can I know? The original code's structure is given. Let me check the original code for similar lines. For example, in the original code, there's a line:\n\ntype *id = id op id;\n\nWhich is a simple operation without parentheses. However, there's also a line:\n\ntype *id = id op id op num;\n\nWhich is a chain of operations. But in the diff, the change is about adding parentheses. If the original code had parentheses in that specific line, then Candidate B would match. Otherwise, not.\n\nAlternatively, perhaps the original code's AST has a certain structure that requires parentheses. For example, if the original code had a certain operator precedence that required parentheses, then Candidate B's version would be correct.\n\nBut without seeing the original code's AST structure, this is challenging. However, the user's criteria are:\n\n1. Topology Match: Does the + code (Candidate B) restore a node type present in the Source but missing in Candidate A?\n\nSo, if the original code (Ground Truth) has a node type (like a certain expression structure) that is missing in Candidate A but present in Candidate B, then Candidate B would be the winner.\n\nFor example, if the original code had a parenthesized expression that Candidate A is missing but Candidate B has, then Candidate B would be the one that matches the"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 2.3125,
          "pr_ppl": 2.296875,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.53125,
          "pr_ast_ppl": 2.515625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses subtraction (-) instead of adding a negative value, which aligns with idiomatic arithmetic expression conventions. This reduces cognitive load by avoiding the explicit use of negative literals, making the operations more intuitive. The parentheses in B also clarify operator precedence without introducing artificial nesting, improving readability while preserving identical logic.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more closely with the Source Code structure by reordering arithmetic operations with explicit parentheses, mirroring the explicit operator precedence and grouping present in the original C code. The structural control flow (e.g., switches, loops) remains unchanged in both versions, but B's adjustments reflect a stylistic preference closer to the original C syntax.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.9140625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.671875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses parentheses to group the arithmetic operation, making the calculation more explicit and reducing ambiguity. This aligns with human-like readability by consolidating the expression into a single, clear term rather than separating it into additive components. The logic remains identical, but the grouped form avoids potential misinterpretation of operator precedence and adheres to cleaner expression structuring.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B corrects the arithmetic expression by properly grouping the multiplication and subtraction with parentheses, aligning with the source code's use of explicit grouping in similar pointer arithmetic operations (e.g., _mid = _lower + ((_upper-_lower) >> 1)). This preserves the intended logic and structural isomorphism.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A avoids unnecessary parentheses, preserving a cleaner expression structure without altering logic. The added parentheses in Candidate B introduce artificial grouping that doesn't reflect a semantic control flow change, violating the tie-breaker rule of preferring less artificial nesting.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores the nested parenthetical structure present in the Source AST, which is critical for matching the original topology. The added parentheses in `+` align with the Source's complex nesting patterns (e.g., multiple nested operations and case statements with braces). Candidate A lacks this structural fidelity.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.9140625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.671875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by grouping arithmetic operations with parentheses, reducing visual noise and making the mathematical intent clearer. The logic remains identical, but the concise expression avoids redundant operations (e.g., '+ -2' vs. '- 2') and aligns with human-friendly expression conventions.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's see. The task is to evaluate which candidate, A or B, is closer to the original source code structure based on the given diff. \n\nFirst, I need to understand the diff. The line in question is:\n\nIn Candidate A: pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\nIn Candidate B: pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n\nSo the difference is in how the arithmetic is structured. The original code (source) probably uses a certain expression here. The key is to see which version matches the source's structure.\n\nLooking at the source code provided, the relevant part is in the _klen handling for the range lengths. The source code has:\n\n_klen = (int)_sav_date_parse_range_lengths[cs];\nif ( _klen > 0 ) {\n    const char *_lower = _keys;\n    const char *_upper = _keys + (_klen<<1) - 2;\n    ...\n\nIn the source, _upper is calculated as _keys + (_klen << 1) - 2. The <<1 is a left shift by 1, which is equivalent to multiplying by 2. So the expression is (_klen * 2) - 2.\n\nNow, looking at the diff. The original code (Candidate A) has (ulong)uVar12 * 2 + -2. Which is the same as (ulong)uVar12 * 2 - 2. Candidate B rewrites this as ((ulong)uVar12 * 2 - 2). \n\nWait, but mathematically, both expressions are the same. However, the structure might differ. The source code uses a left shift (<<1) which is equivalent to multiplying by 2. In the decompiled code, the variable uVar12 is (uint)(char)_sav_date_parse_range_lengths[lVar11], which is the same as _klen. So the original code uses _klen << 1, which is _klen * 2. \n\nIn Candidate A, the expression is (ulong)uVar12 * 2 + -2. This is equivalent to (uVar12 * 2) - 2. Candidate B groups the multiplication and subtraction with parentheses: ((ulong)uVar12 * 2 - 2). \n\nThe source code's equivalent would be using a left shift and then subtracting 2. However, in the decompiled code, the use of * 2 instead of <<1 is a matter of style. But the structure of the expression in the source code is (_klen << 1) - 2. \n\nBut in the diff, the original code (Candidate A) uses * 2 + -2, which is the same as *2 -2. Candidate B uses ((ulong)uVar12 * 2 - 2). The difference here is the parentheses. The original code in the source uses a left shift, but the decompiled code uses multiplication. However, the evaluation is about structural isomorphism. \n\nThe key point is whether the structure matches. The source code uses a left shift (<<1) which is equivalent to multiplying by 2. However, the decompiled code uses *2. But the actual operation is the same. However, the way the expression is written might differ. \n\nIn Candidate A, the expression is written as (ulong)uVar12 * 2 + -2. This is equivalent to (uVar12 * 2) - 2. Candidate B groups the multiplication and subtraction with parentheses, making it clearer. However, the original source code's structure uses a left shift and subtraction. \n\nBut the evaluation criteria mention structural isomorphism. The source code has a switch statement, but the diff here is about a specific arithmetic expression. Since the original code uses a left shift (<<1) which is equivalent to *2, but the decompiled code uses *2. However, the structure of the expression in the source code is (klen << 1) - 2. \n\nIn Candidate A, the expression is (ulong)uVar12 * 2 + -2. Which is the same as (uVar12 * 2) - 2. But the original code uses (klen << 1) - 2. The decompiler might have converted <<1 to *2. So the structure here is similar. \n\nBut the difference between A and B is the way the arithmetic is structured. Candidate B uses parentheses to group the multiplication and subtraction, which might be more in line with the original code's structure. However, the original code uses a left shift, which is a bitwise operation, while the decompiled code uses multiplication. \n\nBut the evaluation criteria focus on control flow structures like switch or for loops. The diff here is about an arithmetic expression, not a control structure. So the structural isomorphism here is about whether the expression matches the original. \n\nIn the source code, the expression is _keys + (_klen << 1) - 2. The decompiled code in Candidate A uses (ulong)uVar12 * 2 + -2, which is equivalent. Candidate B uses ((ulong)uVar12 * 2 - 2). The difference is the order of operations. However, both are mathematically equivalent. \n\nThe correction vs regression: does B fix a logic error in A? The original code's expression is correct. If Candidate A's code is correct, then Candidate B is just a different way of writing the same expression. However, in the original code, the expression is written as (klen << 1) - 2. The decompiled code uses *2 instead of <<1. But since <<1 is equivalent to *2, the code is correct. \n\nSo, the question is whether the structure of the expression in B is closer to the source code. The source code uses a left shift, but the decompiled code uses multiplication. However, the way the arithmetic is structured in B is more explicit. \n\nBut the evaluation criteria don't mention arithmetic expressions, only control flow structures like switch or for. Since the diff is about an arithmetic expression, not a control structure, the structural isomorphism might not be applicable here. \n\nIn that case, the evaluation might be that both versions are structurally isomorphic because they perform the same operation. However, the correction vs regression: if the original code uses <<1 and the decompiled code uses *2, but both are correct, then neither introduces a regression. \n\nBut the question is whether the changes in the diff move the code closer to the source structure. Since the source uses <<1, but the decompiled code uses *2, which is equivalent, but the way it's written in Candidate B is ((ulong)uVar12 * 2 - 2), which is more explicit. However, the original code's structure uses a left shift, which is a different operation. \n\nBut the decompiler might not have the capability to represent <<1 as a left shift, and instead uses multiplication. So in that case, both A and B are correct, but the structure of the expression is different. \n\nSince the evaluation criteria focus on control flow structures (like switch, for), and this diff is about an arithmetic expression, the structural isomorphism might not be applicable here. Therefore, the correction vs regression is the main point. \n\nIf the original code uses <<1, but the decompiled code uses *2, which is equivalent, then both A and B are correct. However, the way the expression is written in B is more explicit. But since the original code uses a left shift, which is a different operation, but the decompiler might not have the capability to represent that. \n\nIn this case, the answer would be that both versions are equivalent, but the original code's structure is not directly matched. However, since the diff is about an arithmetic expression, and the evaluation criteria don't mention arithmetic expressions, the winner might be based on whether the code is correct. \n\nBut the user's instruction says to evaluate based on structural isomorphism and correction vs regression. Since the diff is about an arithmetic expression, and the source code uses a left shift, but the decompiled code uses multiplication, which is equivalent. \n\nIn this case, the answer is that both versions are structurally isomorphic in terms of the arithmetic operation, but Candidate B's expression is more explicit. However, since the original code uses a left shift, which is a different operation, but the decompiler might not have the capability to represent that. \n\nBut the evaluation criteria don't mention arithmetic expressions, so maybe the answer is that both are equivalent, and the winner is B because it's more explicit. However, the original code uses <<1, which is a different operation. \n\nAlternatively, the original code's structure is using a left shift, but the decompiled code uses multiplication. So the decompiler's code is not matching the structure of the original code. However, the evaluation criteria focus on control flow structures, not arithmetic operations. \n\nIn that case, the structural isomorphism isn't applicable here, and the correction vs regression is also not applicable. Therefore, the answer might be that both are equivalent, but the winner is B because it's more explicit. However, the user's instruction says to determine which version is closer to the source code structure. \n\nBut the source code uses a left shift, which is a different operation. However, the decompiled code uses multiplication, which is equivalent. So the structure is different, but the operation is the same. \n\nIn this case, the answer would be that Candidate B is closer to the source code structure because the parentheses make the expression clearer, even"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.59375,
          "base_ppl": 1.953125,
          "pr_ppl": 1.90625,
          "source_ast_ppl": 6.1875,
          "base_ast_ppl": 2.71875,
          "pr_ast_ppl": 2.828125,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem. So, the task is to determine whether the changes in the Diff move the code closer to the Source Code structure or further away. The user is a Senior Compiler Engineer evaluating decompilation fidelity. \n\nFirst, I need to understand the DIFF provided. The lines starting with `-` are Candidate A, and `+` are Candidate B. The specific lines in question are part of a switch statement, probably in a decompiled version of the C code. The original Source Code has a function called lzma_validate_chain, which involves checking filters and their properties.\n\nLooking at the DIFF, the line in question is a condition in a switch case. The original line in Candidate A is: if (1 < lVar7 + 0xbfffffffffffffffU) goto ...; and Candidate B changes it to if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto ...;\n\nNow, the evaluation criteria are Structural Isomorphism and Correction vs Regression. \n\nFor Structural Isomorphism, the Source Code uses a do-while loop with checks on the number of filters, their properties, etc. The DIFF is about a condition inside a switch case, which might be part of the loop's body. The original Source Code uses variables like i, count, and checks on filters. The decompiled code uses variables like lVar7, which might correspond to some counter or value from the original code.\n\nThe key here is whether the condition in Candidate B is closer to the original logic. The original Source Code checks for the number of filters (i > LZMA_FILTERS_MAX) and other conditions. The DIFF's condition involves lVar7, which might be related to the count of filters. \n\nLooking at the mathematical expressions: \n\nOriginal (Candidate A): 1 < lVar7 + 0xbfffffffffffffffU. The 0xbfffffffffffffffU is a very large unsigned value. Adding that to lVar7 might be a way to check if lVar7 is negative, but since it's an unsigned, adding such a large number could be a way to check if lVar7 is beyond a certain limit. However, this seems a bit odd.\n\nCandidate B's condition is 1 < (ulong)(lVar7 - 0x4000000000000001U). The value 0x4000000000000001U is 4 followed by 15 zeros and 1, which is 4.5e18 in decimal. Subtracting that from lVar7 and casting to ulong. \n\nBut how does this relate to the original code? The original code checks if i (the count of filters) exceeds LZMA_FILTERS_MAX (which is 4, as per the comment saying 1-4 filters). So, if the original code checks i > 4, then the decompiled code's condition should reflect that. \n\nBut the original condition in the Source Code is checking for i > LZMA_FILTERS_MAX (which is 4). So, if the decompiled code's condition is trying to represent that, maybe the math here is equivalent. Let's see:\n\nIn the original code, the check is if (i > LZMA_FILTERS_MAX || ...). Let's assume LZMA_FILTERS_MAX is 4. So, i > 4 would be the condition. \n\nIn the decompiled code, the condition is 1 < lVar7 + ... or 1 < ... (the modified version). But how does lVar7 relate to i? If lVar7 is i, then the original check is i > 4. Let's see:\n\nIn Candidate A's condition: 1 < lVar7 + 0xbfffffffffffffffU. Let's compute 0xbfffffffffffffffU. Since it's an unsigned 64-bit value, 0xbfffffffffffffff is 0xb followed by 15 f's. Let's convert that to decimal. 0xb is 11, but in hex, 0xbfffffffffffffff is 0x b followed by 15 f's. Let's calculate that. \n\nBut perhaps there's a better way. Let's think about the original code's check: i > 4. If the decompiled code is trying to represent that, maybe the expression is equivalent. For example, in the original code, the check is i > 4. If lVar7 is i, then the condition would be i > 4. \n\nBut the Candidate A's condition is 1 < lVar7 + 0xbfffffffffffffffU. Let's see: 0xbfffffffffffffffU is a very large number. Adding that to lVar7 would almost certainly be larger than 1, unless lVar7 is a very negative number. But since lVar7 is an unsigned variable (assuming it's a 64-bit unsigned), adding that large number would make it even larger. So this condition would almost always be true, which doesn't make sense. That suggests that Candidate A's condition might be incorrect, perhaps a decompilation error. \n\nCandidate B's condition is 1 < (ulong)(lVar7 - 0x4000000000000001U). Let's compute 0x4000000000000001U. That's 4 followed by 15 zeros and 1, which is 4.5e18 in decimal. If lVar7 is, say, 5 (which is i=5, exceeding the max of 4), then lVar7 - 0x4000000000000001U would be a negative number. Casting that to ulong (which is unsigned) would wrap around to a very large positive number. So the condition 1 < that would be true. But if lVar7 is 4, then subtracting 0x4000... would be negative, same as before. Wait, that doesn't make sense. Maybe I'm missing something here.\n\nAlternatively, perhaps the original code's check is for i > 4, which is equivalent to (i - 5) > -1. But that's not helpful. Alternatively, maybe the decompiled code is trying to represent i > 4 as (i - 5) > -1, but that's not the same. \n\nAlternatively, perhaps the original code's check is i > 4, which can be written as (i - 5) > -1. But that's not helpful. Alternatively, maybe the decompiled code is using some bitwise operations or overflow checks. \n\nAlternatively, maybe the original code's check is for i > 4, and the decompiled code's condition is trying to represent that. Let's think about the math. Suppose lVar7 is i. The original condition is i > 4. Let's see:\n\nIn Candidate B's condition: 1 < (ulong)(lVar7 - 0x4000000000000001U). Let's compute 0x4000000000000001U. That's 4 * 1e18 + 1. If lVar7 is 5, then lVar7 - 0x4000... would be 5 - 4.5e18, which is a negative number. Casting that to ulong (assuming 64-bit) would be 0x... (the two's complement). But 1 < that value would be true, because the ulong is a large number. Wait, but if the subtraction results in a negative number, casting to ulong would make it a large positive number. So 1 < that would be true. But if lVar7 is 4, then 4 - 4.5e18 is also negative, same result. So this condition would be true for any lVar7, which doesn't make sense. \n\nHmm, this seems confusing. Maybe the original code's condition is checking for overflow or something else. Alternatively, perhaps the decompiled code's condition is incorrect. \n\nAlternatively, maybe the original code's check is for i > 4, and the decompiled code's condition is trying to represent that. Let's think of another approach. The original code has a check: if (i > LZMA_FILTERS_MAX || ...). Let's assume LZMA_FILTERS_MAX is 4. So i > 4. \n\nIn the decompiled code, the condition is checking if 1 < (some expression). Let's see what that expression evaluates to. \n\nIn Candidate A: 1 < lVar7 + 0xbfffffffffffffffU. Let's compute 0xbfffffffffffffffU. Let's note that 0x4000000000000000 is 2^62, and 0xbfffffffffffffff is 0xb followed by 15 f's. Let's compute 0xbfffffffffffffff in decimal. \n\nBut maybe there's a better way. Let's think about the original code's check. If the original code checks i > 4, then in decompiled code, maybe the condition is equivalent to (i - 5) > -1. But that's not helpful. Alternatively, maybe the decompiled code is using a different approach due to overflow or underflow. \n\nAlternatively, perhaps the original code's check is for i > 4, which can be written as (i - 5) > -1. But that's not helpful. \n\nAlternatively, maybe the original"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.59375,
          "base_ppl": 1.953125,
          "pr_ppl": 1.90625,
          "source_ast_ppl": 6.1875,
          "base_ast_ppl": 2.71875,
          "pr_ast_ppl": 2.828125,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem. So, the task is to determine whether the changes in the diff move the code closer to the source code structure or further away. The evaluation criteria are structural isomorphism and whether the change is a correction or regression.\n\nFirst, I need to look at the diff provided. The original code (Candidate A) has a line: if (1 < lVar7 + 0xbfffffffffffffffU) goto ...; and Candidate B changes it to if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto ...;\n\nThe source code provided is in C, and the diff seems to be from a decompiled version. The question is about which candidate (A or B) is closer to the original source structure.\n\nLooking at the structural isomorphism: the source code uses control structures like if, for, switch, etc. The diff here is about a specific condition in a switch case. The original source code's logic here might involve checking some condition related to the number of filters or their properties. However, the actual source code's logic isn't directly visible in the diff, but the decompiled code's structure is being compared.\n\nThe key here is to see if the change in Candidate B corrects a logic error present in Candidate A or introduces noise. The original condition in A is comparing 1 < lVar7 + 0xbfffffffffffffffU. The value 0xbfffffffffffffffU is a large unsigned integer. Adding that to lVar7 might be a way to check if lVar7 is beyond a certain threshold. However, in Candidate B, the condition is changed to subtract 0x4000000000000001U from lVar7 and cast to ulong. \n\nWait, let's think about the numerical values. 0xbfffffffffffffffU is 0x4000000000000000U minus 1, right? Because 0x4000000000000000 is 2^61, and subtracting 1 would be 0x3fffffffffffffff. Wait, no, maybe I'm mixing up hex values here. Let me check: 0xbfffffffffffffff is in hex. Let's convert that to decimal. But maybe the key is that the two expressions are mathematically equivalent? Let me see:\n\nOriginal condition: 1 < lVar7 + 0xbfffffffffffffffU. Let's think about what that does. If lVar7 is a 64-bit unsigned integer, adding 0xbfffffffffffffff (which is 0x4000000000000000 - 1 - 0x4000000000000000? Wait, maybe not. Let me think: 0xbfffffffffffffff is 0x4000000000000000 (which is 2^61) minus 0x4000000000000001? No, perhaps the subtraction in Candidate B is equivalent to adding the original value. Wait, maybe there's a mathematical equivalence here. For example, if you have a value x, and you check if x + y > 1, but in another form. Alternatively, maybe the original code was checking for overflow or some other condition.\n\nAlternatively, the change from adding 0xbfffffffffffffffU to subtracting 0x4000000000000001U might be a transformation that's mathematically equivalent. Let me see: Let's say that 0xbfffffffffffffffU is equal to (0x4000000000000000U - 1) - 0x4000000000000000U? No, that doesn't make sense. Wait, 0x4000000000000000 is 2^61. So 0xbfffffffffffffff is 0x4000000000000000 - 0x4000000000000001? No, that would be negative. Wait, perhaps the original expression is lVar7 + 0xbfffffffffffffffU. Let's think of it as lVar7 + (2^61 - 1) - 0x4000000000000000? Not sure. Alternatively, maybe the two expressions are equivalent in some way. For example, if you have 1 < (lVar7 + X), and in the other case, 1 < (lVar7 - Y), but perhaps X and Y are such that X = -Y + something. But this is getting complicated.\n\nAlternatively, maybe the original code had a condition that was supposed to check if lVar7 exceeds a certain value, but due to integer overflow or underflow, the decompiler's output (Candidate A) might have an incorrect expression. Candidate B's change might be a correction to that.\n\nBut without knowing the actual source code's logic here, it's hard to say. However, the evaluation criteria mention that if the + line (Candidate B) fixes a logic error present in -, then it's a correction. Otherwise, it's a regression.\n\nThe original source code's logic here is part of a loop that checks filters. The specific condition in the diff might be part of a check for the number of filters or some other count. However, the diff is in a switch case, which in the source code is part of a larger structure. The structural isomorphism would require that the control flow structures (like if, for, switch) are preserved. However, the diff here is about a specific condition within a switch case, not about the overall structure.\n\nBut the question is whether Candidate B is closer to the source code structure. Since the source code is in C, and the decompiled code is trying to represent that, the correctness of the condition is important. If the original code had a condition that was correctly represented in Candidate B, then B would be better. But if Candidate A's condition is correct and B's is a mistake, then A is better.\n\nBut how can we determine that? The original source code's logic here is not visible, but perhaps the decompiler's output (Candidate A) has an incorrect condition, and Candidate B corrects it. For example, if the original code was checking whether lVar7 is greater than a certain value, and Candidate A's expression is incorrect, while Candidate B's is correct.\n\nAlternatively, perhaps the original code's condition is equivalent to checking if lVar7 is greater than 0x4000000000000000U - 0xbfffffffffffffffU - 1, but that's too vague.\n\nAlternatively, considering that 0xbfffffffffffffffU is 0x4000000000000000U - 0x4000000000000001U? Wait, 0x4000000000000000 is 2^61. Let me compute 0xbfffffffffffffff in hex. Let's see: 0xb is 11 in hex. So 0xbfffffffffffffff is 0x4000000000000000 (which is 2^61) minus 0x4000000000000001? No, that would be negative. Wait, perhaps the original code's condition is checking for overflow. For example, adding a large number to lVar7 and seeing if it's larger than 1. But if lVar7 is a 64-bit unsigned integer, adding 0xbfffffffffffffff (which is 0x4000000000000000 - 1 - 0x4000000000000000? Not sure.\n\nAlternatively, maybe the original code's condition is equivalent to checking if lVar7 is greater than 0x4000000000000000U - 0xbfffffffffffffffU - 1. But this is too vague.\n\nAlternatively, the subtraction in Candidate B might be a way to avoid overflow. For example, if lVar7 is a 64-bit unsigned integer, adding 0xbfffffffffffffffU could cause overflow, but subtracting 0x4000000000000001U might be a way to represent the same condition without overflow. However, without knowing the actual logic, it's hard to say.\n\nBut given that the evaluation criteria ask whether the change is a correction or regression, and since the diff is a single line change, perhaps the original decompiler (Candidate A) had an incorrect expression, and Candidate B corrects it. For example, if the original code was checking for lVar7 being larger than a certain value, and Candidate A's expression is incorrect, while Candidate B's is correct.\n\nAlternatively, maybe the original code uses a 64-bit unsigned integer, and adding 0xbfffffffffffffffU (which is 0x4000000000000000 - 1) would be equivalent to"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the original node type (no 'call' function) present in the Source AST, whereas Candidate B introduces a new 'call' node type not present in the original code. The nesting depth remains unchanged between versions, so topology alignment is prioritized.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + ((long)iVar2 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar2 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 - 0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.9140625,
          "base_ppl": 1.9921875,
          "pr_ppl": 1.9921875,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.234375,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more idiomatic arithmetic expressions (e.g., `((long)iVar2 - 1)` instead of `(long)iVar2 + -1`), which aligns with natural human-readable math notation. The changes avoid explicit negative literals in addition operations, reducing cognitive friction while preserving identical logic. This adheres to the priority of semantic clarity over machine-like expression forms.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more closely with the Source Code structure by using equivalent arithmetic expressions (e.g., `((long)iVar2 - 1)` instead of `(long)iVar2 + -1`), which mirrors the source code's use of subtraction in similar contexts. Both versions preserve the control flow structures (e.g., `for` loops, `switch` cases), but B's changes reflect the source's expression style without introducing structural deviations.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A avoids unnecessary parentheses, preserving concise expression grouping without introducing artificial nesting. The logic remains identical, and reducing redundant syntactic elements aligns with idiomatic design by prioritizing clarity over explicit operator precedence enforcement, which is more human-like in high-level abstraction.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + ((long)local_5c - 1);\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + ((long)(local_5c << 1) - 2);\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 - 1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + ((int)*local_40 - 0x30U);\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 2.09375,
          "pr_ppl": 2.109375,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.203125,
          "pr_ast_ppl": 2.21875,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses subtraction (-1) instead of addition with a negative value (+ -1), which aligns with natural human arithmetic expression. This reduces cognitive load by directly expressing the intent (decrement) rather than using additive inverses. The logic remains identical but the B version uses more idiomatic arithmetic operators that map to human-readable operations.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this evaluation. The user wants to know if the changes in the diff move the code closer to the source structure or not. Let me start by understanding the Source Code and the Diff.\n\nLooking at the Source Code, there's a function with a state machine parsing a timestamp. There are several switch statements and loops, especially in the parts where it handles different cases (like case 0, 1, 2, etc.) for setting fields in the tm struct. The code uses a lot of variables like _trans, _acts, _nacts, and has a loop that processes actions based on the state transitions.\n\nNow, looking at the Diff between Candidate A and B. The changes are in a few lines. Let's go through each diff line by line.\n\nFirst diff:\nIn Candidate A, the line is:\nlocal_88 = local_68 + (long)local_5c + -1;\nIn Candidate B, it's:\nlocal_88 = local_68 + ((long)local_5c - 1);\n\nThis seems like a mathematical equivalence. The original code adds (long)local_5c and then subtracts 1. The B version groups the subtraction into the parentheses. This is just a style change but doesn't affect the structure. So, no impact on control flow.\n\nSecond diff:\nIn Candidate A:\nlocal_a0 = local_68 + (long)(local_5c << 1) + -2;\nIn B:\nlocal_a0 = local_68 + ((long)(local_5c << 1) - 2);\n\nSame as the first change. It's a matter of how the arithmetic is structured. Again, no change in control flow, just a different way of writing the same calculation.\n\nThird diff:\nIn the for loop, Candidate A has:\nlocal_74 = local_74 + -1\nCandidate B has:\nlocal_74 = local_74 - 1\n\nAgain, same operation. The decrement is done in a different way but logically equivalent. No structural change here.\n\nFourth diff:\nIn case 0, Candidate A has:\nlocal_58 = local_58 * 10 + *local_40 + -0x30;\nCandidate B has:\nlocal_58 = local_58 * 10 + ((int)*local_40 - 0x30U);\n\nHere, the original code subtracts 0x30 (which is 48 in decimal) from the byte value. The B version casts *local_40 to int and subtracts 0x30U (which is an unsigned int). The original code might be doing a signed subtraction, but the B version uses an unsigned. However, the source code in the C version uses '0' which is a character, so subtracting '0' (which is 48) from the byte value. The B version's ((int)*local_40 - 0x30U) is equivalent because *local_40 is a char, which when cast to int, and subtracting 0x30U (which is 48) would be the same as the original. However, the original code in the source uses '0' which is a char, so the subtraction is correct. The B version's use of 0x30U might be a bit different, but in terms of arithmetic, it's the same. However, the source code in the C version uses '0' which is a character, so the correct way is to subtract '0' which is 48. But the B version uses 0x30U which is the same value. So maybe it's equivalent. But the structure here is a bit different. However, this is more about the expression than the control flow structure.\n\nAnother diff is in case 0xf:\nCandidate A: local_58 + -0x76c\nCandidate B: local_58 - 0x76c\n\nAgain, same arithmetic. The structure of the code remains the same.\n\nLooking at the evaluation criteria:\n\n1. Structural Isomorphism: The Source Code uses switch statements and for loops. The Candidate B changes are all arithmetic expressions but don't change the presence of switches or loops. So both A and B have the same control flow structures. Therefore, structural isomorphism is the same for both.\n\n2. Correction vs Regression: The question is whether the + lines fix a logic error in A or introduce noise. The changes in B are all arithmetic expressions that are mathematically equivalent. For example, adding a negative number is the same as subtracting. The B version might be more readable or follow a different style, but there's no logic error being fixed. The original code in the source uses '0' which is correct, and the B version's use of 0x30U is equivalent. So, these changes are not corrections but stylistic changes. However, since they don't introduce errors, they might be considered as not introducing noise. But the question is whether the changes move the code closer to the source structure.\n\nWait, the source code in the C version uses '0' which is a character, so subtracting '0' (which is 48) from the byte value. The B version uses 0x30U which is the same value. So the B version is equivalent. However, the original code in the source uses '0' which is a character, but in the decompiled code, it's represented as 0x30U. So maybe the B version is more accurate in terms of the actual value used. However, the structure of the code (like the presence of switch statements, loops, etc.) remains the same in both A and B. Therefore, the structural isomorphism isn't affected by these changes.\n\nSince the changes in B are all equivalent to A but with different expression formatting, and the source code's structure (like switch, for loops) is preserved in both versions, the evaluation would depend on whether the B version is closer to the source code's structure. However, the source code's structure is not directly reflected in the decompiled code's structure, but the decompiled code's structure (like the presence of loops and switches) is the same in both A and B. Therefore, the changes in B don't move the code closer or further from the source structure. However, the question is whether the changes in the diff move the code closer to the source code structure. Since the source code uses '0' (which is 48) and the B version uses 0x30U (which is 48), perhaps the B version is more accurate. However, the structural elements (like the switch statements and loops) are the same in both versions. Therefore, the winner might be B if the arithmetic expressions are more aligned with the source code's intended operations, but since the structural elements are the same, the answer might be that both are equally aligned. However, the evaluation criteria focus on structural isomorphism (presence of switch, for, etc.) and correction vs regression. Since both A and B have the same structures, the winner would be based on correction vs regression. If the B changes are corrections, then B is better. But the changes are not corrections but stylistic. Therefore, perhaps the winner is A, as B doesn't introduce any correction but changes the expressions. However, the problem says to determine if the changes move the code closer to the source code structure. Since the source code uses '0' which is 48, and B uses 0x30U which is the same value, perhaps B is more accurate. But the structural elements are the same. Therefore, the answer might be that both are the same in structure, but B is more accurate in arithmetic expressions. However, the evaluation criteria focus on structural isomorphism (presence of switch, for, etc.), which is the same in both. Therefore, the winner would be based on correction vs regression. Since the B changes don't introduce errors and are equivalent, they are not regressions. However, the original source code uses '0' which is a character, but in the decompiled code, the B version uses 0x30U, which is the same value. So perhaps B is closer to the source code's actual values, but the structural elements are the same. Therefore, the answer might be that both are equally aligned in structure, but B is more accurate in arithmetic expressions. However, the evaluation criteria don't mention arithmetic expressions, only structural elements and correction. Since the structural elements are the same, the winner would be A or B based on correction. But since there's no correction, perhaps the answer is that the changes don't affect the structure, so the winner is A or B. However, the problem says to choose between A and B. Given that the B changes are stylistic but not introducing errors, and the source code's structure is preserved, perhaps the answer is that the changes don't move the code closer or further, but since the question is to choose between A and B, and the B version is more aligned with the actual values (like using 0x30U instead of adding -0x30), maybe B is better. However, the original code in the source uses '0' which is a character, but in the decompiled code, the B version uses 0x30U, which is the same value. Therefore, B's changes are more accurate in terms of the actual value used, which might make B closer to the source code's structure. However, the structural elements (like switch, for) are the same in both. Therefore, the winner is B.\n</think>\n\n{\n  \"motivation\": \"Candidate B aligns more closely with"
        },
        "llm_ast": {
          "motivation": "Candidate A avoids artificial nesting by maintaining minimal parentheses, preserving cleaner logical scope. Candidate B introduces redundant grouping with `((type)id op num)`, which doesn't alter control flow but adds machine-like explicitness. Since the logic is identical, the tie-breaker favors less artificial depth.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.890625,
          "base_ppl": 2.109375,
          "pr_ppl": 2.125,
          "source_ast_ppl": 3.65625,
          "base_ast_ppl": 2.765625,
          "pr_ast_ppl": 2.734375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.890625,
          "base_ppl": 2.140625,
          "pr_ppl": 2.15625,
          "source_ast_ppl": 3.65625,
          "base_ast_ppl": 2.78125,
          "pr_ast_ppl": 2.78125,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        },
        "llm_ast": {
          "motivation": "Candidate A uses a direct expression without unnecessary function wrappers, preserving clarity and avoiding artificial abstraction layers. The 'call()' wrapper in Candidate B introduces an implicit indirection that obscures the direct logical relationship between variables, making the code feel more machine-like.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores the 'call()' node type present in the Source AST (e.g., 'call(&id->id, ...)' in original cases) which is absent in Candidate A. The Source's complexity includes nested calls, and Candidate B's use of 'call()' aligns with this topology.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.5625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 3.109375,
          "base_ast_ppl": 3.0625,
          "pr_ast_ppl": 3.015625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by using explicit subtraction operators (-) instead of adding negative values (+ -...). This aligns with idiomatic C practices where direct arithmetic operations (e.g., `a - b` vs `a + (-b)`) are more human-readable and reduce cognitive load. The changes maintain functional equivalence but prioritize clarity through standard operator usage.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns closer to the Source Code structure by preserving operator precedence and grouping in arithmetic expressions, which mirrors the original C code's logic (e.g., `*pcVar8 - 0x30` aligns with `((*(p))) - '0'` in the source). Candidate A's expressions, while mathematically equivalent, lack explicit grouping, diverging from the source's structure.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.5625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 3.109375,
          "base_ast_ppl": 3.0625,
          "pr_ast_ppl": 3.015625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses parentheses to explicitly group arithmetic operations, enhancing readability by clarifying the logical grouping of terms. While the logic remains identical to Candidate A, the parentheses in B align more closely with human engineering practices by reducing ambiguity in operator precedence and improving visual parsing of expressions.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "motivation": "Candidate B introduces parentheses in expressions (e.g., `((type)id op num op num)`) that align with the Source AST's grouping structure, which relies on explicit operator precedence and nested expressions. These changes restore the nested node topology present in the Ground Truth, whereas Candidate A lacks such grouping, diverging from the Source's complexity and nesting depth.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O0.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + (long)iVar1 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar1 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + *local_2040 + -0x30;\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = *local_2040 + -0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + ((long)iVar1 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar1 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + ((int)*local_2040 - 0x30U);\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = (int)*local_2040 - 0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = *id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = (type)*id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.5625,
          "base_ppl": 1.890625,
          "pr_ppl": 1.90625,
          "source_ast_ppl": 3.109375,
          "base_ast_ppl": 2.640625,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more idiomatic C expressions (e.g., `x - 1` instead of `x + -1`) and avoids synthetic arithmetic forms that obscure intent. The changes preserve identical logic but align with natural human-readable patterns, reducing cognitive friction during code review.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B uses subtraction operations (e.g., ((long)iVar1 - 1)) instead of adding negative values, which aligns more closely with the arithmetic expressions in the Source Code (e.g., _keys + _klen - 1). This preserves the structural isomorphism of the original control flow while maintaining equivalent logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem. The user wants to determine whether Candidate A or B better matches the Source AST topology based on two criteria: Topology Match and Complexity.\n\nFirst, I need to understand what the Ground Truth (Source AST) looks like. From the provided code, there are several instances of expressions involving type casts and operations. For example, lines like \"id = id op (type)id op num;\" and similar structures. The key here is to look at how the expressions are nested, especially the use of parentheses and type casts.\n\nLooking at the AST Diff between A and B, there are a few changes. Let's focus on the specific lines where changes occur. \n\nIn the first diff block (around line 35), Candidate A has \"id = id op (type)id op num;\" while Candidate B changes it to \"id = id op ((type)id op num);\". The difference here is the placement of parentheses. The original Source code (Ground Truth) has \"id op (type)id op num\" without extra parentheses. However, in the Source AST, the structure might require that the operation between (type)id and num is grouped, which Candidate B does by adding parentheses. But wait, the original Source might not have those parentheses. Wait, the Ground Truth's code has expressions like \"type *id = id op id;\" which implies that the op is between two operands. So if the original code didn't have parentheses, adding them might change the operator precedence. However, the question is about AST topology, not the actual code's correctness. The AST structure depends on how the nodes are nested. For example, if the Source has an expression like a op (b op c), the AST would have a node for a, a node for (b op c), etc. So if Candidate B adds parentheses, it might be mirroring the Source's structure if the Source's AST had that grouping.\n\nBut how do I know the Source's structure? The Ground Truth code is the original, so I need to check if the Source's expressions have those parentheses. For example, in the Ground Truth, the line \"type *id = id op id;\" doesn't have parentheses. However, in the diff, Candidate B adds parentheses around (type)id op num. If the Source's AST for that line was structured with the (type)id and num being grouped, then Candidate B would match. But without seeing the actual AST structure, I have to infer based on the code's syntax.\n\nAnother point is the nesting depth. The second criterion is complexity, which relates to nesting depth. If Candidate B's code has the same level of nesting as the Source, that's a plus. For example, if the Source has a certain number of nested expressions, and Candidate B mirrors that, while Candidate A might have a different structure.\n\nLooking at the second diff block (line 55), Candidate A has \"id = id op (type)(id op num) op num;\" and Candidate B changes it to \"id = id op ((type)(id op num) op num);\". Again, adding parentheses around (type)(id op num) op num. If the Source's AST for that line groups (type)(id op num) with num, then Candidate B would be correct. But again, without the actual AST structure, this is tricky.\n\nIn the third diff block (line 78), the change is in the switch case. The original code in the Source has \"id = id op num op *id op num;\" and Candidate B adds parentheses around ((type)*id op num). If the Source's AST for that line groups the operations with parentheses, then Candidate B would be correct. However, the original code in the Source might not have those parentheses, so adding them might be a change in structure.\n\nBut the key is the Topology Match. If the Source AST has a node type that's missing in Candidate A but present in Candidate B, then Candidate B would be the winner. However, the problem states that the Source AST has certain structures, and we need to check if Candidate B restores a node type present in the Source but missing in A.\n\nWait, the first criterion is: Does the `+` code (Candidate B) restore a node type present in the Source but missing in Candidate A? For example, if the Source has a SwitchStatement node, and Candidate A doesn't have it, but Candidate B does, then B would be better. However, looking at the Ground Truth code, there are several switch statements. For example, in the Source, there's a switch((*(id))) with multiple cases. So if Candidate A and B both have switch statements, then that's not the case. But maybe the way the switch is structured in the code?\n\nAlternatively, maybe the issue is about the structure of expressions. For example, if the Source has an expression that requires a certain node structure (like a parenthesized expression node), and Candidate B adds parentheses which create that node, while Candidate A doesn't. \n\nIn the first diff, the Source's line is \"id = id op (type)id op num;\" which in the AST would have the op between id and (type)id, then another op with num. But if the actual structure requires grouping (type)id op num as a single node, then Candidate B's version with parentheses would match that structure. However, the original code doesn't have parentheses, so perhaps the Source's AST doesn't have that grouping. Therefore, maybe the correct answer is that Candidate A is better, but I need to check.\n\nAlternatively, maybe the complexity (nesting depth) is more important. For example, if Candidate B's code has the same nesting depth as the Source, then it would be better. \n\nLooking at the changes, in Candidate B, parentheses are added in several places. For example, in the first diff, the original code is \"id op (type)id op num\" which could be parsed as (id op (type)id) op num, but with parentheses, it's id op ((type)id op num). If the Source's AST for that line is structured as the latter, then Candidate B matches. But without seeing the actual AST, it's hard to tell. However, the problem says that the Ground Truth is the Source AST, so the code provided is the actual code that was decompiled. Therefore, the original code (Source) has expressions without the extra parentheses. Therefore, Candidate A's version is closer to the original code's structure, and Candidate B adds parentheses which might not be present in the Source's AST. \n\nBut the first criterion is about restoring a node type present in the Source but missing in Candidate A. If the Source's AST has a node type that's only present in Candidate B, then B is better. However, without knowing the exact node types, this is challenging. \n\nAlternatively, the problem might be that the Source has certain structures that require parentheses, and Candidate B adds them, thus matching the topology. For example, if the original code had an expression that required grouping, but in the decompiled code (Candidate A), that grouping is missing, leading to a different AST structure. \n\nBut since the user is comparing the decompiled versions (A and B) against the Ground Truth (Source AST), the correct answer would be the one that matches the structure of the Source. If the Source's code has expressions with parentheses, then Candidate B would be correct. However, in the Ground Truth code provided, there are expressions like \"id = id op (type)id op num;\" which includes a (type) cast, but no additional parentheses. So the original code doesn't have the extra parentheses that Candidate B adds. Therefore, Candidate A's version is closer to the original code's structure, and Candidate B's changes might be incorrect. \n\nBut the problem says that the user is a Decompilation Architect comparing AST changes against the Ground Truth. So the correct answer would be the version that, when decompiled, would produce an AST that matches the Source's structure. If the Source's code has certain expressions without parentheses, then Candidate A would be correct. However, the changes in Candidate B add parentheses, which might be necessary if the original AST had those groupings. \n\nThis is a bit ambiguous, but given that the Ground Truth code as provided does not have the extra parentheses that Candidate B adds, I would lean towards Candidate A being the correct one. However, the problem's criteria mention that if Candidate B restores a node type present in the Source but missing in A, then B is better. Without knowing the exact node types, this is tricky. \n\nAlternatively, considering the complexity (nesting depth), if Candidate B's code has the same nesting depth as the Source, then it's better. For example, if the Source has a certain level of nesting, and Candidate B mirrors that, while Candidate A doesn't. \n\nIn the first diff, the original code (Source) has \"id op (type)id op num\" which is two operations. If the AST for that line has two separate operations, then Candidate A's version would match. Candidate B adds parentheses, which might create a different structure. \n\nGiven the uncertainty, but based on the fact that the Ground Truth code doesn't have the extra parentheses, I think Candidate A is more aligned with the Source's structure. Therefore, the winner would be A. However, I need to make sure that the criteria are met. \n\nWait, the first criterion is Topology Match: Does the + code (Candidate B) restore a node type present in the Source but missing in A? If the Source has a node type that requires parentheses (like a parenthesized expression node), and Candidate A doesn't have that node, but Candidate B does, then B would be better. However, without knowing the exact node types, this is hard. \n\nAlternatively, if the Source's AST has a switch statement"
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O2.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.65625,
          "base_ppl": 2.03125,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 3.578125,
          "base_ast_ppl": 2.734375,
          "pr_ast_ppl": 2.765625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more idiomatic arithmetic expressions (e.g., `lVar5 - 1` instead of `lVar5 + -1` and grouping operations with parentheses) which align with natural human-readable math notation. These changes improve clarity without altering logic, making the code's intent more immediately understandable.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns better with Source structure by simplifying arithmetic expressions (e.g., `lVar5 - 1` vs. `lVar5 + -1`) and grouping operations with parentheses, which mirrors typical C code style. These changes improve readability without altering control flow structures, which remain consistent with the original source.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "The structural changes in control flow are identical between candidates. The parentheses in Candidate B do not alter the control flow skeleton or introduce higher-level semantic structures (e.g., loops, switches). Since the logic remains the same, Candidate A avoids unnecessary syntactic grouping, aligning with the tie-breaker rule of preferring less artificial nesting/depth.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O3.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.65625,
          "base_ppl": 2.03125,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 3.578125,
          "base_ast_ppl": 2.734375,
          "pr_ast_ppl": 2.765625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more idiomatic arithmetic expressions (-1 instead of + -1) and clarifies operator precedence with parentheses, aligning with natural human-readable math notation. These changes improve readability without altering logic, making the code more intuitive for human maintenance.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B uses more standard arithmetic notation (subtraction instead of adding a negative), which aligns better with typical C code style. The control flow structures (do-while loops) are preserved in both versions, but B's syntax is closer to the source code's likely structure.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A avoids artificial parentheses that don't alter control flow structure. The logic remains identical between versions, and Candidate A has simpler expression grouping without introducing redundant nesting. Parentheses here don't reflect control flow semantics but merely operator precedence, making Candidate A more idiomatic through minimalism.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.59375,
          "base_ppl": 2.46875,
          "pr_ppl": 2.40625,
          "source_ast_ppl": 6.71875,
          "base_ast_ppl": 5.3125,
          "pr_ast_ppl": 5.25,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by using natural arithmetic expressions (param_3 - 1) instead of param_3 + -1, which aligns with human idiomatic C coding practices. The logical conditions remain functionally identical but are expressed in a more intuitive mathematical form, reducing cognitive friction during code review.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.59375,
          "base_ppl": 2.46875,
          "pr_ppl": 2.40625,
          "source_ast_ppl": 6.71875,
          "base_ast_ppl": 5.3125,
          "pr_ast_ppl": 5.25,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by using explicit subtraction (param_3 - 1) instead of adding a negative value (param_3 + -1). This aligns with human engineering practices by making arithmetic operations more intuitive and reducing cognitive load when interpreting the code's intent. The control flow structures remain identical, but B's expressions better reflect natural mathematical notation.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem. So, the task is to determine whether Candidate A or Candidate B in the AST diff matches the Source AST topology better. The criteria given are Topology Match and Complexity (nesting depth). Let me start by understanding the input data.\n\nFirst, the Ground Truth (Source AST) is a function with several lines of code. It has a for loop with conditions, some assignments, and operations involving id, num, and str. The key elements here are the structure of the loops, the conditions, and the operations.\n\nLooking at the AST Diff between A and B. The differences are in the conditions of the if statements. For example, in the first change, Candidate A has \"id < id op id op num\" while Candidate B has \"id < id op (id op num)\". Similarly, another change in the if condition inside the while loop: A uses \"id op id op num <= id\" and B uses \"id op (id op num) <= id\".\n\nThe first criterion is Topology Match: Does the + (Candidate B) code restore a node type present in the Source but missing in A? The Source AST has a for loop with multiple conditions. However, the diff shows changes in the if conditions. The original Source's if conditions might have different structures. For example, in the Source, the initial if condition is (id->id op id) != num || call(*id). But in the diff, the changes are about grouping operations with parentheses. \n\nWait, maybe the Source has certain operator precedence that's being adjusted in the Candidates. The original code in the Source has expressions like id op id op num. If the parentheses are added in B, that might be changing the operator precedence, which could affect the AST structure. But the question is whether Candidate B restores a node type that's in the Source but missing in A. \n\nLooking at the Source code, the for loop's condition is \"id < id && id < id && *id\". The Candidate A's if condition is \"id < id op id op num\" without parentheses, while B adds parentheses around \"id op num\". The Source's original code might have had similar parenthetical groupings. If the Source's AST has a certain structure with parentheses that Candidate A is missing but B includes, then B would be the winner. \n\nBut how do I know what the original Source's AST structure was? The Ground Truth is the Source AST. Let me check the original code again. The Source has lines like \"type *id, *id = id op id op num;\" which implies that the operations are in a certain order. Also, in the for loop's body, there are conditions like (id->id op id) != num. So the original code uses operator precedence, but perhaps the correct grouping is with parentheses. \n\nIn the diff, Candidate B adds parentheses around parts of the expressions. For example, changing \"id op id op num\" to \"id op (id op num)\". If the original Source's AST had those parentheses, then Candidate B would be restoring that structure, which Candidate A is missing. Therefore, according to the first criterion, if the Source has such parentheses, then B would be the correct choice. \n\nThe second criterion is complexity, which refers to nesting depth. The Source's code has a for loop with nested if statements and while loops. The nesting depth in the Candidates might be similar. However, the diff shows that the changes are in the conditions of the if statements, not in the structure of loops or nesting. So the nesting depth might be the same in both A and B. \n\nTherefore, the main factor here is the Topology Match. If the original Source had parentheses that Candidate A is missing but Candidate B includes, then B is the winner. Since the problem says that the Ground Truth is the Source AST, and the diff is between A and B, the question is whether the parentheses in B match the original structure. \n\nIn the original Source, the line \"type *id, *id = id op id op num;\" suggests that the operations are left-associative. However, in the for loop's condition, the original code has \"id < id && id < id && *id\". But in the Candidates, the changes are about adding parentheses. If the original Source's AST had those parentheses, then B would be correct. \n\nAlternatively, maybe the original code didn't have parentheses, and the Candidates are modifying that. But the problem says that the Ground Truth is the Source AST. So the question is whether the parentheses in B are present in the Source. Since the original code in the Source doesn't show parentheses in those expressions (like \"id op id op num\" without parentheses), then adding parentheses in B would be a change that doesn't match the Source. Wait, but that would mean that Candidate A is closer to the original structure. \n\nWait, this is confusing. Let me re-examine the Ground Truth code. The Source code has lines like:\n\ntype *id, *id = id op id op num;\ntype *id = call(id op id);\ntype *id = id op id;\n\nSo in these assignments, the expressions are written without parentheses. For example, \"id op id op num\" would be evaluated left to right, assuming op is a binary operator. However, in the Candidates, B adds parentheses around parts of the expressions. For example, in the first if condition, Candidate B has \"id < id op (id op num)\" instead of \"id < id op id op num\". \n\nIf the original Source's AST doesn't have those parentheses, then adding them in B would be a change that doesn't match the Source. Therefore, Candidate A would be closer to the original structure. However, the first criterion is whether B restores a node type present in the Source but missing in A. If the original Source's AST has a certain structure (like a specific node type for the expressions with parentheses), but Candidate A doesn't have that node type, while B does, then B would be the winner. \n\nAlternatively, maybe the original Source's AST has a certain structure that requires parentheses, and Candidate A is missing that, but B includes it. But how can I determine that without seeing the actual AST structure? \n\nAlternatively, perhaps the Ground Truth's code has a certain nesting depth. For example, the original code's for loop has a condition with three parts: id < id && id < id && *id. The Candidates modify the if conditions inside the loop. If the nesting depth in the Source is higher, then the complexity (criterion 2) would be considered. \n\nBut the problem states that the Ground Truth is the Source AST. The diff shows that Candidate A and B differ in the conditions of the if statements. The question is whether the structure of the conditions in B matches the Source's structure. \n\nIf the original Source's conditions had parentheses that are present in B but not in A, then B would be the correct choice. However, looking at the original code in the Ground Truth, the conditions don't have parentheses. For example, the first if condition in the Source is (id->id op id) != num || call(*id). But in the diff, the Candidates are changing the structure of the conditions. \n\nWait, the original Source's code has a for loop with a condition that is \"id < id && id < id && *id\". The Candidates are modifying the if conditions inside the loop. For example, in the first change, Candidate A has \"if((id < id op id op num) && (num < id))\" while B has \"if((id < id op (id op num)) && (num < id))\". \n\nIf the original Source's AST for that condition is structured with parentheses, then B would be correct. But if the original code didn't have those parentheses, then A would be correct. However, the original code in the Ground Truth doesn't show parentheses in those expressions. For example, the assignment \"type *id, *id = id op id op num;\" uses left-associative operations. \n\nTherefore, if the original Source's AST doesn't have parentheses in those expressions, then Candidate A would be closer to the original structure. However, the first criterion is whether B restores a node type present in the Source but missing in A. If the original Source's AST has a node type that requires parentheses (like a parenthesized expression node), and Candidate A is missing that, while B includes it, then B would be the winner. \n\nBut without knowing the exact node types in the Source AST, it's challenging. However, the problem says that the Ground Truth is the Source AST, so we can assume that the structure of the conditions in the Source is as written. Therefore, if the original code's conditions don't have parentheses, then Candidate A would be more accurate. However, the problem's first criterion is about restoring a node type that's present in the Source but missing in A. \n\nAlternatively, perhaps the original code's conditions have a certain structure that requires parentheses, and Candidate B adds them, thus matching the Source. But how can I know that? \n\nAlternatively, looking at the line numbers in the diff. The Ground Truth's code has a for loop with a condition that's \"id < id && id < id && *id\". In the Candidates, the changes are in the if conditions. For example, the first if condition in the diff is modified. If the original Source's code had a similar structure with parentheses, then B would be correct. \n\nBut given the ambiguity, perhaps the answer hinges on the parentheses. Since the original code in the Ground Truth doesn't have parentheses in the expressions, Candidate A would be closer. However, the problem's first criterion is about restoring a node type present in the Source but missing in A. If the Source's AST has a node type that requires parentheses (like a parenthesized expression), and"
        }
      },
      {
        "binary": "task-file_strlcpy-O0.so",
        "function": "strlcpy",
        "source_code": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0 && --n != 0) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0)\n\t\t\t\tbreak;\n\t\t} while (--n != 0);\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}\n",
        "function_base": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 + -1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + (-1 - (long)param_2);\n}\n\n",
        "function_pr": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 - 1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + -(long)param_2 + -1;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type id){\n  type *id = id;\n  type *id = id;\n  type id = id;\n  if(id != num && upd id != num){\n    do{\n      if((*id upd = *id upd) == num)break;\n    }while(upd id != num);\n  }\n  if(id == num){\n    if(id != num)*id = str;\n    while(*id upd);\n  }\n  return (id op id op num);\n}",
        "base_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op (num op (type)id);\n}",
        "pr_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op -(type)id op num;\n}",
        "metrics": {
          "source_ppl": 1.6171875,
          "base_ppl": 1.921875,
          "pr_ppl": 1.9140625,
          "source_ast_ppl": 9.5,
          "base_ast_ppl": 3.46875,
          "pr_ast_ppl": 3.59375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by using direct subtraction (`local_38 = local_38 - 1`) instead of adding a negative value, which aligns with natural arithmetic expression patterns. While the return statement expressions are logically identical, B's version avoids the nested parentheses in `(-1 - (long)param_2)` and instead uses a more linear structure (`-(long)param_2 + -1`), reducing visual complexity. The overall change prioritizes idiomatic arithmetic operations, making the code more intuitive for human readers.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B uses a more direct decrement operation (local_38 - 1) which aligns with the source code's use of --n. The return statement's arithmetic restructuring in B mirrors the source's (s - src - 1) expression, maintaining structural equivalence without altering control flow.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem step by step. The goal is to determine whether Candidate A or Candidate B in the provided diff matches the Source AST topology better based on the given criteria.\n\nFirst, I need to understand the Ground Truth (Source AST) code. The function is defined as type id(type *id, type *id, type id). Inside the function, there are assignments, conditionals, loops, and a return statement. The key part here is the return statement in the Source AST: return (id op id op num);. \n\nLooking at the AST Diff, the return statement in Candidate A is written as return id op (num op (type)id);. In Candidate B, it's return id op -(type)id op num;. \n\nThe first criterion is Topology Match: Does the + (Candidate B) code restore a node type present in the Source but missing in Candidate A? The Source's return statement has a certain structure. Let's compare the expressions.\n\nIn the Source, the return is (id op id op num). The parentheses here might indicate a specific grouping. In Candidate A, the expression is id op (num op (type)id). This changes the grouping: num is grouped with the second id, and then that result is op with the first id. In Candidate B, it's id op -(type)id op num. The subtraction operator here might be a typo or a different operation, but the structure is id op something op num. \n\nWait, the original Source uses 'op' which could be an operator like addition or something else. The exact operator isn't specified, but the structure is important. The Source's return is (id op id op num). The parentheses here might be grouping the first two id's together, then that result op with num. But in the Source code, the parentheses are around the first two id's. \n\nIn Candidate A, the expression is id op (num op (type)id). So the grouping is num op (type)id, which is different from the Source's grouping. In Candidate B, the expression is id op -(type)id op num. The parentheses here are around -(type)id, which might be a cast or a unary minus. However, the original Source didn't have a cast or a unary minus. \n\nSo, looking at the Topology Match criterion: does Candidate B restore a node type present in the Source but missing in A? The Source's return statement has a certain structure. If Candidate A's structure is different (grouping num and id), while Candidate B's structure is closer to the original, but with a cast. However, the Source's return statement doesn't have a cast. \n\nWait, the original Source's return is (id op id op num). The parentheses here might be indicating that the first two id's are grouped together. In Candidate A, the parentheses are around num op (type)id, which is a different grouping. In Candidate B, the expression is id op -(type)id op num. The parentheses here are around -(type)id, which is a cast (type)id with a unary minus. But the original Source doesn't have that. \n\nSo, perhaps the Source's return statement has a certain operator precedence or grouping. If the original code uses parentheses to group the first two id's, then the correct structure would be (id op id) op num. \n\nIn Candidate A, the grouping is id op (num op (type)id), which changes the order of operations. In Candidate B, the grouping is id op (-(type)id) op num. The parentheses here might be changing the grouping again. \n\nBut the problem is about the AST topology. The Source's return statement has a certain structure. If Candidate B's code restores the node type (like the grouping) that's present in the Source but missing in A, then B would be the winner. However, the Source's return is (id op id op num), which could be parsed as (id op id) op num. \n\nIn Candidate A, the expression is id op (num op (type)id). This is different in grouping. In Candidate B, the expression is id op -(type)id op num. The parentheses here are around -(type)id, which is a unary minus and cast. The original Source doesn't have that. \n\nSo, perhaps the key is the presence of the cast (type)id. In the Source, the return statement is (id op id op num). There's no cast here. Candidate A has (type)id, which is a cast. Candidate B also has (type)id but with a unary minus. \n\nWait, the original Source's code has assignments like type *id = id; and type id = id;. So the cast (type)id is present in the Source code. For example, in the line type *id = id; the cast is implicit. But in the return statement, the original code is return (id op id op num);. There's no cast there. \n\nSo, the Source's return statement doesn't have a cast. Therefore, if Candidate A includes a cast (type)id, that's not present in the Source. Candidate B also has (type)id but with a unary minus. \n\nHmm, this is confusing. Let me re-examine the original Source code. The return statement is return (id op id op num);. The parentheses here might be indicating that the first two id's are grouped together. \n\nIn Candidate A, the return is id op (num op (type)id). The grouping here is different. In Candidate B, the return is id op -(type)id op num. The parentheses here are around -(type)id, which is a cast and a unary minus. \n\nThe first criterion is whether Candidate B restores a node type present in the Source but missing in A. The Source's return statement doesn't have a cast, but in the Source code, there are assignments with casts. However, the return statement itself doesn't have a cast. \n\nWait, the original code has lines like type *id = id; which is a cast. So the cast (type) is present in the Source code. However, in the return statement, the original code is (id op id op num), which doesn't have a cast. \n\nSo, if Candidate A has (type)id in the return statement, that's a cast that's not present in the Source's return statement. Therefore, Candidate A introduces a cast that's not in the Source. Candidate B also has (type)id but with a unary minus. \n\nWait, the original Source's return is (id op id op num). The parentheses here might be for grouping. The actual AST structure would have the operators in a certain order. \n\nThe second criterion is Complexity: Does the + code match the nesting depth of the Source? The nesting depth of the return statement in the Source is just a single return statement. The expressions in the return are three terms with operators. \n\nIn Candidate A, the expression is id op (num op (type)id). The nesting depth here is two levels of parentheses. In Candidate B, it's id op -(type)id op num. The parentheses here are only around -(type)id, which is one level. \n\nThe original Source's return is (id op id op num). The parentheses here are grouping the first two terms. So the nesting depth is one level. \n\nTherefore, Candidate B's nesting depth (one level) matches the Source's, whereas Candidate A has two levels. So according to the Complexity criterion, Candidate B would be better. \n\nAdditionally, the Topology Match: Does Candidate B restore a node type present in the Source but missing in A? The Source's return statement doesn't have a cast, but the original code does have casts elsewhere. However, the return statement in the Source doesn't have a cast. So Candidate A introduces a cast that's not present in the Source's return statement. Candidate B has a cast, but the original Source's return statement doesn't. However, the original code does have casts in other parts. \n\nThis is a bit ambiguous. However, the main point is that the return statement in the Source doesn't have a cast. So if Candidate B's code has a cast (type)id, that's not present in the Source's return statement. However, the original code does have casts elsewhere, but the return statement's structure is different. \n\nAlternatively, maybe the key is that the Source's return is (id op id op num), which is a binary operation between id and (id op num). But the exact structure depends on operator precedence. However, the parentheses in the Source indicate that the first two id's are grouped. \n\nIn Candidate B, the expression is id op -(type)id op num. The parentheses here are around -(type)id, which is a unary operation. The original Source's return doesn't have a unary minus. \n\nThis is tricky. However, based on the Complexity criterion, Candidate B's nesting depth (one level) matches the Source's, whereas Candidate A has a deeper nesting. Therefore, Candidate B is more aligned with the Source's structure. \n\nAdditionally, the original return statement's structure is (id op id op num). If the correct grouping is (id op id) op num, then Candidate B's structure is id op (something) op num. If the 'something' is -(type)id, which is a different operand, but the structure of the operators is similar. \n\nBut the main difference is the presence of the cast. However, the original code does have casts in other parts, but not in the return statement. \n\nGiven that, perhaps the answer is that Candidate B is the winner because it matches the nesting depth (Complexity) and the structure of the return statement, even if the cast is present"
        }
      },
      {
        "binary": "task-file_file_printable-O0.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + param_3 + -1) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + param_3 + -4 <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + (param_3 - 1)) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + (param_3 - 4) <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op id op num) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op id op num <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op (id op num)) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op (id op num) <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.59375,
          "base_ppl": 2.21875,
          "pr_ppl": 2.203125,
          "source_ast_ppl": 6.71875,
          "base_ast_ppl": 5.5,
          "pr_ast_ppl": 5.5,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by using parentheses to explicitly group arithmetic operations (param_3 - 1 instead of param_3 + -1). This aligns with human engineering practices by reducing cognitive load through clearer expression of intent, while maintaining identical logic flow. The change avoids potential confusion with operator precedence and presents the mathematics in a more natural form.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      }
    ],
    "deepseek-r1": [
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.625,
          "base_ast_ppl": 2.34375,
          "pr_ast_ppl": 2.328125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by using more idiomatic expressions. The use of subtraction (`-`) instead of adding a negative (`+ -1`) is cleaner. Additionally, the parentheses in the calculation make the order of operations clearer, enhancing semantic structure and reducing ambiguity.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B maintains the same control flow structures as the Source Code and improves readability without introducing new control structures. The changes are syntactic improvements that do not alter the logic or structure negatively.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A maintains a cleaner and more natural expression without unnecessary parentheses, which doesn't add to the idiomatic structure. The change in B is a syntactic modification that doesn't improve the semantic structure or control flow.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B introduces parentheses that better reflect the nesting depth and structure of the Source AST, aligning with the complexity and topology.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.625,
          "base_ast_ppl": 2.34375,
          "pr_ast_ppl": 2.328125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by simplifying expressions and using more idiomatic control flow. For instance, replacing `iVar3 = iVar3 + -1` with `iVar3 = iVar3 - 1` is cleaner. Additionally, the arithmetic expression grouping in `puVar13` is clearer in B, enhancing semantic structure.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Both versions maintain the same control flow structures as the source. However, Candidate B's changes, such as the arithmetic expression grouping, align more closely with typical code style and readability without altering functionality, making it marginally closer to the source structure.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A avoids unnecessary parentheses, maintaining a cleaner and more natural structure that reflects logical flow without artificial complexity.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B introduces an additional level of nesting with parentheses, aligning better with the Source's complex structure and deeper nesting.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.671875,
          "base_ppl": 2.28125,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.9375,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns better with the Source Code structure by correctly calculating the range lengths and simplifying the loop variables with proper subtraction, ensuring the code's logic matches the original.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.671875,
          "base_ppl": 2.296875,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 2.9375,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by simplifying expressions and using more natural decrement operations, making the code flow clearer and more maintainable.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B's changes simplify the code without altering the control flow, aligning more closely with the Source's structure by using clearer operations.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A avoids unnecessary artificial nesting with fewer parentheses, maintaining cleaner code structure.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + ((long)iVar7 - 1);\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + ((long)(iVar7 << 1) - 2);\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 - 1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c - 1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 1.9921875,
          "pr_ppl": 1.9921875,
          "source_ast_ppl": 2.625,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by using more idiomatic control flow and clearer expressions. The changes in B use subtraction instead of adding negative values, which is more natural and aligns with typical loop structures. Additionally, the use of parentheses clarifies the operations, enhancing readability and reducing cognitive load.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces parentheses to improve readability and aligns with the Source's style of explicit grouping, making the code structurally closer to the Source.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + ((long)iVar7 - 1);\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + ((long)(iVar7 << 1) - 2);\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc - 1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c - 1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.671875,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.9375,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more explicit parentheses to clarify the order of operations, improving readability and reducing ambiguity. This aligns with human engineering practices by making the code structure clearer and more maintainable.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B improves code readability by correctly applying parentheses, aligning more closely with the Source's structure without altering functionality.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.625,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 2.703125,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "motivation": "Candidate B correctly groups operations, matching the Source's AST complexity and nesting depth.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.625,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 2.703125,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces minor optimizations that don't alter the control flow or structural isomorphism but improve code readability and conciseness without introducing errors.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.015625,
          "base_ppl": 2.609375,
          "pr_ppl": 2.59375,
          "source_ast_ppl": 2.59375,
          "base_ast_ppl": 2.875,
          "pr_ast_ppl": 2.875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        },
        "llm_ast": {
          "motivation": "Candidate B introduces unnecessary parentheses, adding artificial nesting which complicates the code without improving readability or logic. This makes it less idiomatic compared to Candidate A, which is cleaner and maintains a more natural structure.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B introduces parentheses that better reflect the nesting depth in the Source AST, aligning with the complex structure of nested operations and conditionals.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.015625,
          "base_ppl": 2.609375,
          "pr_ppl": 2.59375,
          "source_ast_ppl": 2.59375,
          "base_ast_ppl": 2.875,
          "pr_ast_ppl": 2.875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B combines the calculation into a single line, improving readability and reducing unnecessary nesting. This makes the code cleaner and easier to follow, aligning with human engineering practices by avoiding spaghetti-like code structures.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B's change correctly calculates the expression by grouping the operations, aligning better with the Source's straightforward arithmetic handling and improving readability without altering control flow.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B adds unnecessary parentheses, which do not enhance the control flow structure. This change introduces a syntactic artifact without improving the semantic structure, making Candidate A more human-like.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 2.140625,
          "pr_ppl": 2.109375,
          "source_ast_ppl": 8.625,
          "base_ast_ppl": 3.0625,
          "pr_ast_ppl": 3.171875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "Okay, so I'm trying to figure out which version of the code is better in terms of human engineering practices. The diff shows two versions: Candidate A and Candidate B. I need to compare them based on the given hierarchy, which prioritizes semantic structure over graph artifacts.\n\nLooking at the diff, the change is in the condition of an if statement. In Candidate A, the condition is `if (1 < lVar7 + 0xbfffffffffffffffU)`. In Candidate B, it's `if (1 < (ulong)(lVar7 - 0x4000000000000001U))`.\n\nFirst, I should understand what each condition is doing. The original condition adds a very large number (0xbfffffffffffffffU) to lVar7. That's a hexadecimal number which is a large positive value. So, 0xbfffffffffffffffU is 11 bits set, which is 0x8000000000000000 is 2^63, so 0xbfffffff is 0x8000000000000000 + 0x7fffffff, which is a large positive number.\n\nIn Candidate B, the condition subtracts 0x4000000000000001U from lVar7 and casts it to ulong. Wait, but lVar7 is likely a long variable, which in C is 64 bits. So, subtracting 0x4000000000000001U from lVar7 and then casting to ulong. Hmm, but why would you subtract that?\n\nWait, maybe I should think about what these operations mean in terms of the condition. Let's see: 1 is a small number, so the condition is checking if 1 is less than something.\n\nIn Candidate A, the condition is 1 < (lVar7 + 0xbfffffffffffffffU). Since 0xbfffffffffffffffU is a large positive number, adding it to lVar7 would make the sum very large. So, this condition is checking if lVar7 is greater than (1 - 0xbfffffffffffffffU), which is a negative number. So, if lVar7 is greater than a very negative number, which it almost always is, unless lVar7 is negative.\n\nWait, but lVar7 is a long, which can be negative. So, if lVar7 is negative, adding 0xbfffffffffffffffU (which is a large positive) might cause an overflow or underflow. But in C, adding a positive and a negative long could result in underflow, but in this case, since 0xbfffffff... is a 64-bit number, adding it to lVar7 would result in a very large value if lVar7 is positive, or could wrap around if lVar7 is negative.\n\nBut perhaps the actual logic is that the condition is trying to check if lVar7 is within a certain range. Let me think about the two conditions:\n\nCandidate A: 1 < lVar7 + 0xbfffffffffffffffU\nWhich can be rewritten as lVar7 > (1 - 0xbfffffffffffffffU). Since 0xbfffffffffffffffU is a large positive number, 1 minus that is a very negative number. So, the condition is checking if lVar7 is greater than a very negative number, which is almost always true unless lVar7 is negative and its value is less than that.\n\nBut in Candidate B, the condition is 1 < (lVar7 - 0x4000000000000001U) cast to ulong. Wait, but casting to ulong would convert the result to an unsigned 64-bit integer. So, if lVar7 - 0x4000000000000001U is negative, casting to ulong would result in a large positive number because in two's complement, negative numbers become large positives when cast to unsigned.\n\nWait, that might not be right. Let me think again. If lVar7 is a long, which is signed 64-bit. Subtracting 0x4000000000000001U from it. Let's see what 0x4000000000000001U is. It's 4 followed by 59 zeros and a 1, which is 2^58 +1. So, it's a very large number, about 4e17.\n\nSo, if lVar7 is greater than or equal to 0x4000000000000001U, subtracting it would give a positive number. If lVar7 is less than that, subtracting would give a negative number, which when cast to ulong becomes a large positive number (since in two's complement, negative numbers become large positives when cast to unsigned).\n\nSo, the condition in Candidate B is 1 < (lVar7 - 0x4000000000000001U) as a ulong. Wait, but in C, when you subtract a larger number from a smaller one, you get a negative number, which when cast to ulong becomes a large positive (since it's two's complement). So, the condition is checking if 1 is less than that value.\n\nBut why would someone write it that way? Let me think about what the condition is trying to achieve.\n\nIn Candidate A, the condition is 1 < lVar7 + 0xbfffffffffffffffU. Let's compute 0xbfffffffffffffffU. That's 0xb followed by 15 f's in hex, which is 64 bits. 0xb is 11 in hex, so each digit is 4 bits. So, 0xbfffffffffffffffU is 11 followed by 15 f's, which is 11111111111111111111111111111111 in binary, which is all ones except the first bit. Wait, no, 0xb is 1011 in binary, so 0xb followed by 15 f's (which are 1111 in binary each) would make a 64-bit number where the first four bits are 1011 and the rest are 1111. So, it's a very large number, but not the maximum 64-bit value. The maximum is 0xffffffffffffffff, which is 18446744073709551615.\n\nWait, 0xbfffffffffffffffU is equal to 0x00000000bfffffffffffffff in 64 bits, which is 11 followed by 15 f's. Wait, no, 0xb is 11 in hex, so 0xb followed by 15 f's would be 16 bits? No, wait, 64 bits. Each hex digit is 4 bits, so 0xb is 4 bits, followed by 15 f's (each 4 bits) would make 16 hex digits, which is 64 bits. So, 0xbfffffffffffffffU is 11 followed by 15 f's, which is 0xb followed by 15 f's, making a 64-bit number.\n\nBut perhaps the key is to see what the condition is doing. Let me think about the two conditions:\n\nCandidate A: 1 < lVar7 + 0xbfffffffffffffffU\nWhich is equivalent to lVar7 > 1 - 0xbfffffffffffffffU. Since 0xbfffffffffffffffU is a large positive number, 1 minus that is a very negative number. So, the condition is checking if lVar7 is greater than a very negative number, which is almost always true unless lVar7 is negative and less than that.\n\nBut in Candidate B, the condition is 1 < (lVar7 - 0x4000000000000001U) cast to ulong. Wait, but casting to ulong would change the sign. So, if lVar7 is less than 0x4000000000000001U, then lVar7 - 0x4000000000000001U is negative, and when cast to ulong, it becomes a large positive number (since in two's complement, negative numbers become large positives when cast to unsigned). So, the condition 1 < (something) would be checking if 1 is less than that large positive number, which is always true because the large positive number is much bigger than 1.\n\nWait, but that doesn't make sense. Let me think again. If lVar7 is less than 0x4000000000000001U, then lVar7 - 0x4000000000000001U is negative, and when cast to ulong, it becomes a large positive number because of two's complement. So, the condition 1 < (ulong)(lVar7 - 0x4000000000000001U) would be 1 < (a large positive number), which is always true.\n\nWait,"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        },
        "llm_ast": {
          "motivation": "Candidate A uses a simpler condition without unnecessary function calls, maintaining clarity and directness, which aligns better with human-like logical structures.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 2.140625,
          "pr_ppl": 2.109375,
          "source_ast_ppl": 8.625,
          "base_ast_ppl": 3.0625,
          "pr_ast_ppl": 3.171875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "motivation": "Candidate B introduces a function call in the condition, aligning with the Source's AST which likely includes such a call, better matching the topology.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + ((long)iVar2 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar2 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 - 0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.015625,
          "base_ppl": 2.171875,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 2.59375,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.328125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by grouping operations and using more natural expressions, aligning with idiomatic control flow and better semantic structure.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more closely with the Source's structure by simplifying expressions without altering control flow, thus enhancing readability and fidelity.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + ((long)local_5c - 1);\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + ((long)(local_5c << 1) - 2);\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 - 1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + ((int)*local_40 - 0x30U);\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.34375,
          "pr_ppl": 2.34375,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 2.34375,
          "pr_ast_ppl": 2.359375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B simplifies expressions with clearer grouping and operations, enhancing readability and aligning with idiomatic control flow.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B's changes align with the Source's structure by simplifying expressions without altering the logic, maintaining the original control flow and improving readability.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.359375,
          "base_ppl": 2.359375,
          "pr_ppl": 2.375,
          "source_ast_ppl": 3.890625,
          "base_ast_ppl": 2.890625,
          "pr_ast_ppl": 2.890625,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.359375,
          "base_ppl": 2.40625,
          "pr_ppl": 2.421875,
          "source_ast_ppl": 3.890625,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.890625,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.734375,
          "pr_ppl": 2.6875,
          "source_ast_ppl": 3.359375,
          "base_ast_ppl": 3.203125,
          "pr_ast_ppl": 3.171875,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by grouping related operations, making the code more human-like with clearer and more logical structure.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.734375,
          "pr_ppl": 2.6875,
          "source_ast_ppl": 3.359375,
          "base_ast_ppl": 3.203125,
          "pr_ast_ppl": 3.171875,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by simplifying expressions, making the code more idiomatic and easier to understand. The changes reduce cognitive load by grouping operations and using clearer syntax.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B better aligns with the source's switch structure by clearly grouping operations, enhancing readability without altering logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores a SwitchStatement node and maintains the correct nesting depth by correctly grouping operations, aligning with the Source's complexity.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O0.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + (long)iVar1 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar1 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + *local_2040 + -0x30;\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = *local_2040 + -0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + ((long)iVar1 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar1 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + ((int)*local_2040 - 0x30U);\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = (int)*local_2040 - 0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = *id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = (type)*id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.078125,
          "pr_ppl": 2.09375,
          "source_ast_ppl": 3.359375,
          "base_ast_ppl": 2.828125,
          "pr_ast_ppl": 2.78125,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores the correct node types and nesting depth present in the Source AST, better reflecting the original structure.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O2.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.328125,
          "base_ppl": 2.390625,
          "pr_ppl": 2.359375,
          "source_ast_ppl": 4.28125,
          "base_ast_ppl": 2.875,
          "pr_ast_ppl": 2.84375,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by simplifying arithmetic expressions and using more intuitive operations like subtraction instead of adding a negative. This aligns with human-like abstraction and clarity.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "Error",
          "motivation": "Okay, so I need to evaluate which version of the code, A or B, is closer to the source code structure. The source code provided is a function called lzma_raw_coder_init, which initializes some filters based on whether it's an encoder or not. \n\nLooking at the diff, the changes are in the loops and variable assignments. Let me go through each part step by step.\n\nFirst, in the diff, lines with '-' are from Candidate A, and '+' are from Candidate B. The main focus is on the structural isomorphism and whether the changes fix logic errors or introduce noise.\n\nStarting with the first part of the diff:\n\nIn Candidate A, there's a line: lVar5 = lVar5 + -1;\nIn Candidate B, it's changed to: lVar5 = lVar5 - 1;\n\nThis is a minor change. Both lines effectively subtract 1 from lVar5. The source code uses a for loop with i < count, and in both candidates, the loop is decrementing lVar5. So structurally, both versions maintain the loop correctly. However, B's line is slightly cleaner, but it's a matter of style, not structure.\n\nNext, looking at the second part of the diff:\n\nIn Candidate A, the line is: puVar4 = puVar4 + -3;\nIn Candidate B, it's: puVar4 = puVar4 + -3; Wait, no, looking again, in the second part, the line is: puVar4 = puVar4 + -3; and in the diff, the change is in another part. Wait, let me check again.\n\nWait, the diff shows:\n\nIn the else if block, Candidate A has:\n\npuVar4 = local_a8 + local_b0 * 3 + -1;\n\nAnd Candidate B changes it to:\n\npuVar4 = local_a8 + (local_b0 * 3 - 1);\n\nSo in A, it's adding local_b0*3 and then subtracting 1, all added to local_a8. In B, it's grouped as (local_b0*3 -1), then added to local_a8. This is a matter of operator precedence and code readability. Both compute the same value, so structurally, they are equivalent. However, B's version is more readable as it clearly groups the multiplication and subtraction.\n\nAnother point is the do-while loops. Both versions have similar structures, with the loop body and the condition. The variable assignments inside the loop are similar, just with minor changes in variable names or arithmetic operations.\n\nNow, considering the evaluation criteria: \n\n1. Structural Isomorphism: The source code uses for loops with i < count, and the diff shows similar loops in both candidates. The control flow structures (if-else, loops) are preserved in both, so both A and B maintain the structural isomorphism.\n\n2. Correction vs Regression: The changes in B don't fix any logic errors in A; they are just style or readability improvements. However, they don't introduce any regressions either. The operations are functionally equivalent.\n\nSo, does B improve the code without changing the logic? Yes, but it's not fixing any errors. It's more about code clarity.\n\nBut wait, looking back at the source code, in the encoder case, the loop is from i=0 to count, but j is count - i -1. So the loop is iterating in reverse. In the diff, the changes are in the loop variables and assignments, but the structure remains the same.\n\nIn the diff, the changes are in variable assignments and arithmetic expressions, not in the control flow structures. So both versions have the same control flow as the source.\n\nHowever, in terms of code readability and clarity, B's changes make the expressions more concise. For example, (local_b0 *3 -1) is clearer than adding -1 after multiplication. This could be seen as an improvement in readability without changing functionality.\n\nBut since the evaluation is about moving closer to the source structure, and both versions have the same control flow, the structural isomorphism is the same. The changes in B don't add or remove any control structures, just make the code a bit cleaner.\n\nSo, considering that, neither version is structurally closer than the other in terms of control flow. However, B's changes might be seen as better in terms of code quality, but not necessarily closer in structure.\n\nWait, but the source code uses for loops with ++i, and in the diff, the loops are using do-while with lVar5 being decremented. Hmm, that's a bit different. Let me check the source code again.\n\nWait, the source code has for loops with for (size_t i = 0; i < count; ++i). The diff's code seems to have do-while loops with variables being decremented. So in the source, it's a for loop, but in the diff, it's a do-while loop. That's a structural change.\n\nWait, looking at the diff:\n\nIn the first part, the code has:\n\ndo {\n    ...\n} while (lVar5 != 0);\n\nAnd in the source, it's a for loop. So the control flow structure is different. So in the diff, the code is using a do-while loop, whereas the source uses a for loop. That would mean that the structural isomorphism is not met in the diff, but the source uses a for loop.\n\nWait, but the diff is part of the function, which is a decompiled version. So the original source uses for loops, but the decompiled code uses do-while. So in the diff, which version is closer to the source structure?\n\nIf the source uses for loops, then the version in the diff that uses for loops would be closer. But in the diff provided, the code uses do-while loops, which is different from the source's for loops.\n\nWait, perhaps I'm getting confused. The source code is the ground truth, and the diff is between two decompiled versions. The question is, which decompiled version is closer to the source structure.\n\nSo in the source, the loops are for loops. In the diff, the code has do-while loops. So if one of the candidates (A or B) uses for loops, it would be closer. But looking at the diff, both candidates have do-while loops, as the changes are within the same structure.\n\nWait, no, the diff shows changes in the loop variables and arithmetic, but the loop structure (do-while) is the same in both candidates. So neither is using a for loop, which is what the source has. Therefore, neither is structurally isomorphic in terms of control flow.\n\nBut that can't be right because the source uses for loops, and the decompiled code might have converted them to do-while. So perhaps the structural isomorphism is not about the exact loop type, but the overall structure.\n\nAlternatively, perhaps the structural isomorphism is about the presence of loops and conditionals, not the exact type. But the evaluation criteria says that the source uses 'for' and the winner must have 'for' if that's the case.\n\nWait, the evaluation criteria says:\n\n1. Structural Isomorphism: Which version (A or B) matches the control flow structures of the Source Code?\n\n- Source 'switch' -> winner must have 'switch'.\n- Source 'for' -> winner must have 'for'.\n\nSo if the source uses a 'for' loop, the winner must have a 'for' loop. If the decompiled code uses a 'do-while' instead, it's not isomorphic.\n\nBut in the diff, both candidates are using do-while loops, which is different from the source's for loops. So neither A nor B would satisfy the structural isomorphism because they don't have 'for' loops.\n\nWait, that can't be right because the diff is part of a larger function. Maybe I'm misunderstanding the context.\n\nWait, perhaps the diff is showing changes in a part of the code that was originally a for loop but is now a do-while in both candidates. So the source has a for loop, but the decompiled code has a do-while. Therefore, neither A nor B would match the source's control flow structure, but the question is which is closer.\n\nAlternatively, perhaps the structural isomorphism is about the presence of loops and the general flow, not the exact type. But according to the criteria, if the source uses a 'for' loop, the winner must have a 'for' loop.\n\nIn that case, if neither A nor B has a 'for' loop, then neither is isomorphic. But that's not possible because the source uses 'for' loops, and the decompiled code would have to have 'for' loops to match.\n\nWait, perhaps I'm misreading the diff. Let me look again.\n\nThe diff shows lines in the function where the code is using do-while loops. The source code uses for loops. So in the decompiled code, the loops are do-while, which is a different structure from the source's for loops.\n\nTherefore, neither A nor B would have the same control flow structure as the source, which uses 'for' loops. But that can't be the case because the evaluation is between A and B, and one must be the winner.\n\nWait, perhaps I'm misunderstanding the context. The diff is part of a larger function, and the specific lines being changed are within a loop. The source code uses for loops, but the decompiled code uses do-while. So in terms of structural isomorphism, the version that uses for loops would be closer.\n\nBut in the diff, both candidates are using do-while loops, so neither is using for loops. Therefore, neither is structurally isomorphic. But that can't be the case because the evaluation"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O3.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.328125,
          "base_ppl": 2.390625,
          "pr_ppl": 2.359375,
          "source_ast_ppl": 4.28125,
          "base_ast_ppl": 2.875,
          "pr_ast_ppl": 2.84375,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by simplifying arithmetic expressions and reducing artificial nesting, making the code more idiomatic and easier to follow.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "motivation": "Candidate A matches the Source AST's structure without adding parentheses, whereas Candidate B introduces a grouped expression not present in the Source, altering the node type.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.484375,
          "base_ppl": 3.109375,
          "pr_ppl": 3.03125,
          "source_ast_ppl": 7.5,
          "base_ast_ppl": 5.90625,
          "pr_ast_ppl": 5.84375,
          "delta_ppl": -0.078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by using parentheses to clearly group operations, making the code more idiomatic and easier to understand. This aligns with human engineering practices by avoiding potential confusion from the order of operations in Candidate A.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B simplifies the condition to (param_3 - 1), which aligns better with the source's loop structure and improves readability without altering the logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B introduces parentheses that clarify the order of operations, enhancing readability and reducing ambiguity. This makes the code more human-like by improving clarity without adding unnecessary complexity.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.484375,
          "base_ppl": 3.109375,
          "pr_ppl": 3.03125,
          "source_ast_ppl": 7.5,
          "base_ast_ppl": 5.90625,
          "pr_ast_ppl": 5.84375,
          "delta_ppl": -0.078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by simplifying complex expressions with parentheses, making the logic clearer and more maintainable. This aligns with human-like abstraction and semantic structure.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "motivation": "Candidate A has a cleaner structure with less nesting and clearer control flow, making it more human-like and idiomatic.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-file_strlcpy-O0.so",
        "function": "strlcpy",
        "source_code": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0 && --n != 0) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0)\n\t\t\t\tbreak;\n\t\t} while (--n != 0);\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}\n",
        "function_base": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 + -1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + (-1 - (long)param_2);\n}\n\n",
        "function_pr": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 - 1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + -(long)param_2 + -1;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type id){\n  type *id = id;\n  type *id = id;\n  type id = id;\n  if(id != num && upd id != num){\n    do{\n      if((*id upd = *id upd) == num)break;\n    }while(upd id != num);\n  }\n  if(id == num){\n    if(id != num)*id = str;\n    while(*id upd);\n  }\n  return (id op id op num);\n}",
        "base_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op (num op (type)id);\n}",
        "pr_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op -(type)id op num;\n}",
        "metrics": {
          "source_ppl": 2.28125,
          "base_ppl": 2.234375,
          "pr_ppl": 2.234375,
          "source_ast_ppl": 12.9375,
          "base_ast_ppl": 3.625,
          "pr_ast_ppl": 3.78125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "motivation": "Candidate A correctly mirrors the Source AST's nested structure with two levels of binary operations, whereas Candidate B flattens the structure, reducing the nesting depth and altering the topology.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_printable-O0.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + param_3 + -1) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + param_3 + -4 <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + (param_3 - 1)) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + (param_3 - 4) <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op id op num) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op id op num <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op (id op num)) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op (id op num) <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.484375,
          "base_ppl": 3.015625,
          "pr_ppl": 2.9375,
          "source_ast_ppl": 7.5,
          "base_ast_ppl": 6.03125,
          "pr_ast_ppl": 6.03125,
          "delta_ppl": -0.078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B simplifies the expressions by using subtraction directly, making the code more readable and idiomatic. This aligns with human engineering practices by improving clarity and reducing unnecessary complexity.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "Error",
          "motivation": "Okay, so I'm trying to figure out whether the changes in the Diff make the code closer to the Source Code structure or not. I'm a bit new to this, but I'll try to break it down step by step.\n\nFirst, I need to understand the Source Code structure. Looking at the Source Code, it's a C function with a for loop that processes a string. The loop continues as long as ptr is less than eptr, s is less than es, and *s is not zero. Inside the loop, there are some conditions: if the flags are set or the character is printable, it copies the character. Otherwise, it breaks if there's not enough space, and then escapes the character by writing three more bytes.\n\nNow, looking at the Diff between Candidate A and B. The changes are in the loop structure and some conditions. The Source uses a for loop, but the Candidates A and B have a while(true) loop. That's a big difference because the Source's control flow is a for loop, not a while loop.\n\nIn the Source, the loop is straightforward with three conditions. In the Candidates, they have a while(true) loop with an if condition that sets a boolean bVar3, and then breaks based on that. This seems more complex and less similar to the Source's structure.\n\nLooking at the conditions inside the loop: the Source checks if the flags are set or if the character is printable. The Candidates have similar logic but with different variable names and structures. However, the main issue is the control flow structure.\n\nThe evaluation criteria mention Structural Isomorphism. The Source has a for loop, so the winner should have a for loop. Both Candidates have a while loop, which doesn't match the Source. Wait, but looking again, the Candidates are in a while(true) loop, which is a different structure than the Source's for loop. So neither A nor B matches the Source's structure perfectly. But the question is whether the change in the Diff moves closer or further.\n\nWait, the Diff shows that in Candidate B, the condition is changed from (local_38 < param_2 + param_3 + -1) to (local_38 < param_2 + (param_3 -1)). That seems like a simplification, but the bigger issue is the loop structure.\n\nThe Source uses a for loop with three conditions, but the Candidates use a while loop. So neither is structurally isomorphic. But the question is whether the change in the Diff (from A to B) makes it closer or further.\n\nWait, the initial code in the Diff is Candidate A, and the changes are to Candidate B. So the question is whether the changes in B are better than A in terms of matching the Source.\n\nBut the Source has a for loop, while both A and B have a while loop. So neither is matching the Source's structure. However, maybe the while loop is a more accurate representation than the for loop? Or perhaps the condition in B is more similar to the Source's logic.\n\nWait, the Source's for loop initializes ptr, and the condition is ptr < eptr, s < es, and *s. The Candidates' while loop has a condition that's more complex, involving local variables and parameters. So perhaps the while loop is a better match if the Source's logic can be represented that way.\n\nAlternatively, maybe the while loop is a transformation that's more similar to the Source's logic in terms of the conditions. But I'm not sure. The main point is that the Source uses a for loop, so the version that has a for loop would be better.\n\nBut in the Diff, both A and B have while loops. So maybe the change from A to B is making the condition more accurate. For example, in A, the condition is (local_38 < param_2 + param_3 + -1), which is param_2 + param_3 -1. In B, it's param_2 + (param_3 -1), which is the same as A but written differently. So perhaps it's a style change, but not affecting the structure.\n\nWait, maybe the variables are different. In the Source, the loop variables are ptr, s, and the conditions are on ptr and s. In the Candidates, the variables are local_38 and local_48, which might correspond to ptr and s. So the while loop is trying to replicate the for loop's conditions.\n\nBut the Source's for loop has three conditions: ptr < eptr, s < es, and *s. The Candidates' while loop has a condition that combines local_38 (which is ptr) and local_48 (which is s). So the while loop's condition is similar to the Source's for loop condition.\n\nSo perhaps the while loop is a correct transformation, but the Source uses a for loop. So in terms of structural isomorphism, neither A nor B is a perfect match, but the while loop might be a more accurate representation of the logic.\n\nAlternatively, maybe the while loop is more complex and introduces more noise, making it a regression. But the change in the condition from +param_3 + -1 to + (param_3 -1) is just a matter of code style, not logic.\n\nWait, the condition in A is (local_38 < param_2 + param_3 + -1), which is equivalent to param_2 + param_3 -1. In B, it's (local_38 < param_2 + (param_3 -1)), which is the same as A. So the change is just a matter of code formatting, not logic. So it's not introducing any functional change, just making the code a bit cleaner.\n\nIn terms of correction vs regression, the change doesn't fix any logic error; it's just a style change. So it's neutral in that aspect.\n\nBut the main evaluation is structural isomorphism. The Source uses a for loop, so the version that has a for loop would be better. However, both Candidates have a while loop, so neither is matching the Source's structure. But perhaps the while loop is a better representation of the logic than the for loop, even though it's a different structure.\n\nAlternatively, maybe the while loop is a more accurate translation of the Source's logic, even though it's a different control structure. So in that case, the change from A to B might be better because it's making the condition clearer, even if it's not a for loop.\n\nWait, but the Source's for loop is straightforward, with clear initialization and conditions. The Candidates' while loop is more nested and has a condition that's more complex. So perhaps the while loop is moving away from the Source's structure.\n\nHmm, I'm a bit confused. Let me try to summarize:\n\n- Source uses a for loop with three conditions.\n- Candidates use a while(true) loop with a condition that combines two variables.\n- The change in the condition is just a style change, not affecting logic.\n\nSo, in terms of structural isomorphism, the while loop doesn't match the Source's for loop. Therefore, neither A nor B is a perfect match, but the question is whether the change in the Diff (from A to B) is better or worse.\n\nThe change in the condition is just a matter of code style, so it's not introducing any functional change. Therefore, it's not a correction but also not a regression. But in terms of structure, the while loop is a different control flow than the Source's for loop.\n\nSo, perhaps the while loop is a more accurate representation of the logic, even though it's a different structure. Or maybe it's less accurate because it's more complex.\n\nI think the key point is that the Source uses a for loop, so the version that uses a for loop would be better. But in the Candidates, both have a while loop, so neither is better in terms of structural isomorphism.\n\nWait, but the question is whether the change in the Diff (from A to B) moves closer or further. So if in A, the condition is written as param_3 + -1, which is less readable, and in B, it's param_3 -1, which is clearer, then B is better in terms of code clarity, even if the control structure is different.\n\nAlternatively, maybe the while loop is a better representation of the logic than the for loop, even though it's a different structure.\n\nI'm not entirely sure, but I think the main issue is that the Source uses a for loop, and the Candidates use a while loop. Therefore, neither is a perfect match, but the while loop might be a more accurate translation of the logic, even if it's a different structure.\n\nSo, considering that, the change from A to B doesn't affect the control structure but makes the condition slightly clearer. Therefore, it's a minor improvement but doesn't change the structural isomorphism.\n\nAlternatively, maybe the while loop is a more accurate representation of the logic, so B is better.\n\nWait, the Source's for loop has three conditions: ptr < eptr, s < es, and *s. The Candidates' while loop condition seems to combine two variables, which might correspond to the same conditions. So perhaps the while loop is a correct transformation, but the Source uses a for loop, so the version that uses a for loop would be better.\n\nBut in the Candidates, both have a while loop, so neither is better in terms of structural isomorphism. However, the change in the condition from A to B is a style improvement, so B is better in that aspect.\n\nBut the main evaluation is structural isomorphism, which is about matching the control flow structures. Since the Source uses a for loop and the Candidates use a while loop, neither is a perfect match. However, the while loop might be a more accurate representation of the logic, even if it"
        },
        "llm_ast": {
          "motivation": "The change adds parentheses in the condition, which doesn't significantly improve the control flow structure. The original code maintains the same semantic structure with clear nesting, making it more human-like in terms of logical scope.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      }
    ],
    "mistral": [
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.859375,
          "base_ppl": -1,
          "pr_ppl": 1.6875,
          "source_ast_ppl": 2.34375,
          "base_ast_ppl": 2.109375,
          "pr_ast_ppl": 2.109375,
          "delta_ppl": 2.6875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.859375,
          "base_ppl": 1.6875,
          "pr_ppl": 1.6875,
          "source_ast_ppl": 2.34375,
          "base_ast_ppl": 2.109375,
          "pr_ast_ppl": 2.109375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8984375,
          "base_ppl": 1.828125,
          "pr_ppl": 1.828125,
          "source_ast_ppl": 2.578125,
          "base_ast_ppl": 2.25,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8984375,
          "base_ppl": 1.828125,
          "pr_ppl": 1.828125,
          "source_ast_ppl": 2.578125,
          "base_ast_ppl": 2.25,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + ((long)iVar7 - 1);\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + ((long)(iVar7 << 1) - 2);\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 - 1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c - 1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.859375,
          "base_ppl": 1.6796875,
          "pr_ppl": 1.6875,
          "source_ast_ppl": 2.34375,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.015625,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + ((long)iVar7 - 1);\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + ((long)(iVar7 << 1) - 2);\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc - 1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c - 1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8984375,
          "base_ppl": 1.671875,
          "pr_ppl": 1.6796875,
          "source_ast_ppl": 2.578125,
          "base_ast_ppl": 2.0,
          "pr_ast_ppl": 2.0,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.6015625,
          "base_ppl": 2.171875,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.390625,
          "pr_ast_ppl": 2.390625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.6015625,
          "base_ppl": 2.171875,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.390625,
          "pr_ast_ppl": 2.390625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.6328125,
          "base_ppl": 2.09375,
          "pr_ppl": 2.09375,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 2.53125,
          "pr_ast_ppl": 2.53125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.6328125,
          "base_ppl": 2.09375,
          "pr_ppl": 2.09375,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 2.53125,
          "pr_ast_ppl": 2.53125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns with the Source Code structure better. It maintains the same logic flow and control structures, including the switch-case construct and the for loop, which are present in the Source Code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.46875,
          "base_ppl": 1.828125,
          "pr_ppl": 1.796875,
          "source_ast_ppl": 5.84375,
          "base_ast_ppl": 2.734375,
          "pr_ast_ppl": 2.875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.46875,
          "base_ppl": 1.828125,
          "pr_ppl": 1.796875,
          "source_ast_ppl": 5.84375,
          "base_ast_ppl": 2.734375,
          "pr_ast_ppl": 2.875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + ((long)iVar2 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar2 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 - 0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6328125,
          "base_ppl": 1.8671875,
          "pr_ppl": 1.875,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 2.171875,
          "pr_ast_ppl": 2.171875,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + ((long)local_5c - 1);\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + ((long)(local_5c << 1) - 2);\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 - 1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + ((int)*local_40 - 0x30U);\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6015625,
          "base_ppl": 2.03125,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.171875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.734375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.890625,
          "source_ast_ppl": 3.359375,
          "base_ast_ppl": 2.53125,
          "pr_ast_ppl": 2.53125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.734375,
          "base_ppl": 1.8984375,
          "pr_ppl": 1.921875,
          "source_ast_ppl": 3.359375,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": 0.0234375
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.046875,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.796875,
          "pr_ast_ppl": 2.765625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.046875,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.796875,
          "pr_ast_ppl": 2.765625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O0.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + (long)iVar1 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar1 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + *local_2040 + -0x30;\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = *local_2040 + -0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + ((long)iVar1 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar1 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + ((int)*local_2040 - 0x30U);\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = (int)*local_2040 - 0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = *id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = (type)*id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.046875,
          "base_ppl": 1.765625,
          "pr_ppl": 1.78125,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O2.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 1.8515625,
          "pr_ppl": 1.859375,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 2.765625,
          "pr_ast_ppl": 2.734375,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O3.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 1.8515625,
          "pr_ppl": 1.859375,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 2.765625,
          "pr_ast_ppl": 2.734375,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.59375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.234375,
          "source_ast_ppl": 6.53125,
          "base_ast_ppl": 5.3125,
          "pr_ast_ppl": 5.15625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.59375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.234375,
          "source_ast_ppl": 6.53125,
          "base_ast_ppl": 5.3125,
          "pr_ast_ppl": 5.15625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-file_strlcpy-O0.so",
        "function": "strlcpy",
        "source_code": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0 && --n != 0) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0)\n\t\t\t\tbreak;\n\t\t} while (--n != 0);\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}\n",
        "function_base": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 + -1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + (-1 - (long)param_2);\n}\n\n",
        "function_pr": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 - 1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + -(long)param_2 + -1;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type id){\n  type *id = id;\n  type *id = id;\n  type id = id;\n  if(id != num && upd id != num){\n    do{\n      if((*id upd = *id upd) == num)break;\n    }while(upd id != num);\n  }\n  if(id == num){\n    if(id != num)*id = str;\n    while(*id upd);\n  }\n  return (id op id op num);\n}",
        "base_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op (num op (type)id);\n}",
        "pr_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op -(type)id op num;\n}",
        "metrics": {
          "source_ppl": 1.4609375,
          "base_ppl": 1.828125,
          "pr_ppl": 1.8671875,
          "source_ast_ppl": 9.3125,
          "base_ast_ppl": 3.546875,
          "pr_ast_ppl": 3.578125,
          "delta_ppl": 0.0390625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-file_file_printable-O0.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + param_3 + -1) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + param_3 + -4 <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + (param_3 - 1)) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + (param_3 - 4) <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op id op num) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op id op num <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op (id op num)) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op (id op num) <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.59375,
          "base_ppl": 2.140625,
          "pr_ppl": 2.140625,
          "source_ast_ppl": 6.53125,
          "base_ast_ppl": 5.4375,
          "pr_ast_ppl": 5.4375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      }
    ],
    "phi-4": [
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6328125,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.7734375,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.0625,
          "pr_ast_ppl": 2.0625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns with the source structure by improving readability without altering logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6328125,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.7734375,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.0625,
          "pr_ast_ppl": 2.0625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6484375,
          "base_ppl": 1.90625,
          "pr_ppl": 1.8984375,
          "source_ast_ppl": 2.578125,
          "base_ast_ppl": 2.234375,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns with the source structure by improving clarity and correctness in pointer arithmetic without altering control flow.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6484375,
          "base_ppl": 1.9140625,
          "pr_ppl": 1.90625,
          "source_ast_ppl": 2.578125,
          "base_ast_ppl": 2.234375,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + ((long)iVar7 - 1);\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + ((long)(iVar7 << 1) - 2);\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 - 1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c - 1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6328125,
          "base_ppl": 1.671875,
          "pr_ppl": 1.671875,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 1.9453125,
          "pr_ast_ppl": 1.953125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + ((long)iVar7 - 1);\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + ((long)(iVar7 << 1) - 2);\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc - 1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c - 1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6484375,
          "base_ppl": 1.6875,
          "pr_ppl": 1.6953125,
          "source_ast_ppl": 2.578125,
          "base_ast_ppl": 1.9453125,
          "pr_ast_ppl": 1.9609375,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.3359375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.203125,
          "base_ast_ppl": 2.390625,
          "pr_ast_ppl": 2.375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.3359375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.203125,
          "base_ast_ppl": 2.390625,
          "pr_ast_ppl": 2.375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B simplifies expressions for clarity without altering the logic, aligning more closely with the source code structure.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.375,
          "base_ppl": 2.21875,
          "pr_ppl": 2.203125,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 2.515625,
          "pr_ast_ppl": 2.5,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.375,
          "base_ppl": 2.21875,
          "pr_ppl": 2.203125,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 2.515625,
          "pr_ast_ppl": 2.5,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "motivation": "Both candidates maintain the same structural alignment with the source code. Candidate B uses a more conventional expression format.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.328125,
          "base_ppl": 1.828125,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 6.21875,
          "base_ast_ppl": 2.609375,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.328125,
          "base_ppl": 1.828125,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 6.21875,
          "base_ast_ppl": 2.609375,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + ((long)iVar2 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar2 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 - 0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.375,
          "base_ppl": 1.953125,
          "pr_ppl": 1.9609375,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 2.109375,
          "pr_ast_ppl": 2.109375,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B maintains the structural isomorphism with the source code and simplifies expressions without altering logic, making it closer to the source code structure.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + ((long)local_5c - 1);\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + ((long)(local_5c << 1) - 2);\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 - 1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + ((int)*local_40 - 0x30U);\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.3359375,
          "base_ppl": 2.0,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.203125,
          "base_ast_ppl": 2.109375,
          "pr_ast_ppl": 2.125,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.625,
          "base_ppl": 1.9609375,
          "pr_ppl": 1.9609375,
          "source_ast_ppl": 3.328125,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.625,
          "base_ppl": 1.9609375,
          "pr_ppl": 1.9609375,
          "source_ast_ppl": 3.328125,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B corrects potential logic errors present in Candidate A by using more conventional and clear operations for comparison and decrementing.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5546875,
          "base_ppl": 2.1875,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.765625,
          "pr_ast_ppl": 2.734375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5546875,
          "base_ppl": 2.1875,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.765625,
          "pr_ast_ppl": 2.734375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O0.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + (long)iVar1 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar1 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + *local_2040 + -0x30;\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = *local_2040 + -0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + ((long)iVar1 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar1 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + ((int)*local_2040 - 0x30U);\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = (int)*local_2040 - 0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = *id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = (type)*id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.5546875,
          "base_ppl": 1.796875,
          "pr_ppl": 1.796875,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.421875,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more closely with the source code structure by simplifying arithmetic expressions without altering the logic, thus maintaining the intended control flow and actions.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O2.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 1.8203125,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 3.328125,
          "base_ast_ppl": 2.59375,
          "pr_ast_ppl": 2.578125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B simplifies and clarifies the loop control and arithmetic expressions, aligning more closely with typical C code practices and improving readability without altering logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O3.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 1.8203125,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 3.328125,
          "base_ast_ppl": 2.59375,
          "pr_ast_ppl": 2.578125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "motivation": "Candidate A maintains the original expression structure from the Source AST without altering the operation grouping, thus preserving the topology and complexity.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 1.9375,
          "pr_ppl": 1.8984375,
          "source_ast_ppl": 6.71875,
          "base_ast_ppl": 4.96875,
          "pr_ast_ppl": 4.9375,
          "delta_ppl": -0.0390625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 1.9375,
          "pr_ppl": 1.8984375,
          "source_ast_ppl": 6.71875,
          "base_ast_ppl": 4.96875,
          "pr_ast_ppl": 4.9375,
          "delta_ppl": -0.0390625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-file_strlcpy-O0.so",
        "function": "strlcpy",
        "source_code": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0 && --n != 0) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0)\n\t\t\t\tbreak;\n\t\t} while (--n != 0);\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}\n",
        "function_base": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 + -1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + (-1 - (long)param_2);\n}\n\n",
        "function_pr": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 - 1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + -(long)param_2 + -1;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type id){\n  type *id = id;\n  type *id = id;\n  type id = id;\n  if(id != num && upd id != num){\n    do{\n      if((*id upd = *id upd) == num)break;\n    }while(upd id != num);\n  }\n  if(id == num){\n    if(id != num)*id = str;\n    while(*id upd);\n  }\n  return (id op id op num);\n}",
        "base_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op (num op (type)id);\n}",
        "pr_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op -(type)id op num;\n}",
        "metrics": {
          "source_ppl": 1.234375,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 9.1875,
          "base_ast_ppl": 3.4375,
          "pr_ast_ppl": 3.4375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B uses more idiomatic C expressions that align better with the source code's structure and intent.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "motivation": "Candidate B aligns with the Source structure by maintaining the same number of operands and avoiding unnecessary nesting.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-file_file_printable-O0.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + param_3 + -1) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + param_3 + -4 <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + (param_3 - 1)) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + (param_3 - 4) <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op id op num) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op id op num <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op (id op num)) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op (id op num) <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 1.9296875,
          "pr_ppl": 1.8671875,
          "source_ast_ppl": 6.71875,
          "base_ast_ppl": 5.4375,
          "pr_ast_ppl": 5.375,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      }
    ]
  }
}