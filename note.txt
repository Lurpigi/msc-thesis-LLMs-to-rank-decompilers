doom supera i 2 mb quindi non posso usarlo con dogbolt

alla fine aveva API nascoste.. lo shell è stato modificato per funzionare nel container e saltare un decompilatore non più disponibile

modelli scaricati su ollama:
llama3.2:3b 2GB
gpt-oss:20b 14GB
deepseek-r1:14b 9GB
gemma3:12b 8.1GB


si può usare api con ollama, però prima devo capire se posso rendere tutto indipendente dal SO, 
sicuramente ollama girerà sul desktop con windows, ma magari llama3.2 riesco a farlo girare sul portatile.

forse installare ollama su wsl per usare justfile senza problemi.

problemi:
limite 2MB per dogbolt
limite context window ollama (128k token) limite lunghezza messaggio llm esterni.

trovare framework per auotmatizzare futuri flow.
capire se dividere in più prompt magari aggiungendo commenti senza modificare il codice per aiutare il LLM come su deGPT
o più prompt per diverse metriche (humanity, complexity, perplexity) -> limiti msg llm esterni


https://lmarena.ai/leaderboard
https://scale.com/leaderboard


https://tiktokenizer.vercel.app/

si basa su tiktoken di Openai, forse installarlo e aggiungerlo al flow senza passare dal sito (crush con messaggi lunghi di modelli non openai)


ghidra
https://ghidra.re/ghidra_docs/api/index.html
https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/package-summary.html

https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core
https://scrapco.de/ghidra_docs/Features/Base/GhidraScriptMgrPlugin/ScriptDevelopment.htm#:~:text=,than%20simple%20edits%20to%20scripts
https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompInterface.html

https://www.nccgroup.com/research-blog/earlyremoval-in-the-conservatory-with-the-wrench-exploring-ghidra-s-decompiler-internals-to-make-automatic-p-code-analysis-scripts
https://github.com/nneonneo/ghidra-wasm-plugin/blob/master/src/main/java/ghidra/program/emulation/WasmEmulateInstructionStateModifier.java

https://www.nccgroup.com/research-blog/earlyremoval-in-the-conservatory-with-the-wrench-exploring-ghidra-s-decompiler-internals-to-make-automatic-p-code-analysis-scripts
https://spinsel.dev/2021/04/02/ghidra-decompiler-debugging.html

MCP
https://medium.com/@clearbluejar/supercharging-ghidra-using-local-llms-with-ghidramcp-via-ollama-and-openweb-ui-794cef02ecf7
https://medium.com/data-science-in-your-pocket/model-context-protocol-mcp-using-ollama-e719b2d9fd7a !!
https://github.com/fosdickio/binary_ninja_mcp

https://github.com/aaddrick/claude-desktop-debian/releases/tag/v1.1.5%2Bclaude0.13.11


extensions
https://github.com/cyberkaida/reverse-engineering-assistant/blob/main/src/main/java/reva/plugin/RevaPlugin.java
https://github.com/Nalen98/GhidraEmu
https://github.com/ZeroDaysBroker/GhidraGPT/tree/main/src/main/java/ghidragpt

ghidra stack decomp

https://reverseengineering.stackexchange.com/questions/20905/ghidra-control-flow-graph
https://grant-h.github.io/docs/ghidra/decompiler/files.html
https://github.com/NationalSecurityAgency/ghidra/discussions/5433#discussioncomment-6338755

https://radareorg.github.io/blog/posts/sleigh_disassembler_backend/

https://cgit.git.savannah.gnu.org/cgit/coreutils.git/tree/src

https://github.com/LukeSerne/RuleChef/tree/master
https://github.com/LukeSerne/DecompVis?tab=readme-ov-file#usage


perplexity

https://www.geeksforgeeks.org/nlp/perplexity-for-llm-evaluation/
https://github.com/coreutils/coreutils
https://github.com/ollama/ollama/issues/2415




ruleaction.hh -> definizione di classi che poi sono regole di traduzione da pcode, semplificazioni o funzioni utili (get)
ruleaction.cc -> implementazione delle classi scritte nel .hh, limitate da scope e commenti

blockaction.cc -> regole da flowblock a stutture in C, non c'è più divisione tra vari "stili" -> 
                            CollapseStructure::collapseInternal
                            BlockWhileDo::finalTransform -> from while to for

coreaction.cc -> void ActionDatabase::buildDefaultGroups(void) -> dichiarazione degli stili di azione
                void ActionDatabase::universalAction(Architecture *conf) -> deinizione vari ActionGoup con collegamento delle regole

ActionGroup -> insieme di regole che vengono effettuate in sequenza (generalmente) l'ordine potrebbe cambiare il risultato //Alcuni hanno la proprietà rule_repeatapply -> l'intero gruppo di azioni viene ripetuto finché non vengono più apportate modifiche
ActionPool -> insieme di regole che vengono eseguite in "contemporanea" iterando sui pcode di una funzione

new rule("fase di analisi")

ordine di esecuzione dipende dall'ordine di implementazione, no gerarchie

Vernode -> struttura che implementa una variabile di basso livello o un insieme contiguo di byte, descritta da un Address e una size

action.cc ->
            *ActionDatabase::deriveAction(const string &baseaction, const string &grp) -> funzione per generare una action da eseguire dal basegroup


make decomp_opt -j$(nproc)      # SLEIGH optimized
make decomp_dbg                 # SLEIGH debug
./gradlew buildGhidra           #build




RuleChef

SimplifyLessAndNotEqual:	BOOL_AND(INT_LESSEQUAL(a, b), INT_NOTEQUAL(a, b))       => INT_LESS(a, b)	            -----Da (a <= b && a != b) a (a < b).
SimplifyGreaterAndNotEqual:	BOOL_AND(INT_SLESSEQUAL(a, b), INT_NOTEQUAL(a, b))	    => INT_SLESS(a, b)	            -----Da (a >= b && a != b) a (a > b).
SimplifyOrEqual:	        BOOL_OR(INT_LESS(a, b), INT_EQUAL(a, b))	            => INT_LESSEQUAL(a, b)	        -----Da (a < b || a == b)  a (a <= b).
SimplifyConditionalCopy:	BOOL_NEGATE(INT_EQUAL(a, b))	                        => INT_NOTEQUAL(a, b)	        -----Da !(a == b)          a (a != b).