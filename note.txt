doom supera i 2 mb quindi non posso usarlo con dogbolt

alla fine aveva API nascoste.. lo shell è stato modificato per funzionare nel container e saltare un decompilatore non più disponibile

modelli scaricati su ollama:
llama3.2:3b 2GB
gpt-oss:20b 14GB
deepseek-r1:14b 9GB
gemma3:12b 8.1GB


si può usare api con ollama, però prima devo capire se posso rendere tutto indipendente dal SO, 
sicuramente ollama girerà sul desktop con windows, ma magari llama3.2 riesco a farlo girare sul portatile.

forse installare ollama su wsl per usare justfile senza problemi.

problemi:
limite 2MB per dogbolt
limite context window ollama (128k token) limite lunghezza messaggio llm esterni.

trovare framework per auotmatizzare futuri flow.
capire se dividere in più prompt magari aggiungendo commenti senza modificare il codice per aiutare il LLM come su deGPT
o più prompt per diverse metriche (humanity, complexity, perplexity) -> limiti msg llm esterni


https://lmarena.ai/leaderboard
https://scale.com/leaderboard


https://tiktokenizer.vercel.app/

si basa su tiktoken di Openai, forse installarlo e aggiungerlo al flow senza passare dal sito (crush con messaggi lunghi di modelli non openai)


ghidra
https://ghidra.re/ghidra_docs/api/index.html
https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/package-summary.html

https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core
https://scrapco.de/ghidra_docs/Features/Base/GhidraScriptMgrPlugin/ScriptDevelopment.htm#:~:text=,than%20simple%20edits%20to%20scripts
https://ghidra.re/ghidra_docs/api/ghidra/app/decompiler/DecompInterface.html

https://www.nccgroup.com/research-blog/earlyremoval-in-the-conservatory-with-the-wrench-exploring-ghidra-s-decompiler-internals-to-make-automatic-p-code-analysis-scripts
https://github.com/nneonneo/ghidra-wasm-plugin/blob/master/src/main/java/ghidra/program/emulation/WasmEmulateInstructionStateModifier.java

https://www.nccgroup.com/research-blog/earlyremoval-in-the-conservatory-with-the-wrench-exploring-ghidra-s-decompiler-internals-to-make-automatic-p-code-analysis-scripts
https://spinsel.dev/2021/04/02/ghidra-decompiler-debugging.html

MCP
https://medium.com/@clearbluejar/supercharging-ghidra-using-local-llms-with-ghidramcp-via-ollama-and-openweb-ui-794cef02ecf7
https://medium.com/data-science-in-your-pocket/model-context-protocol-mcp-using-ollama-e719b2d9fd7a !!
https://github.com/fosdickio/binary_ninja_mcp

https://github.com/aaddrick/claude-desktop-debian/releases/tag/v1.1.5%2Bclaude0.13.11


extensions
https://github.com/cyberkaida/reverse-engineering-assistant/blob/main/src/main/java/reva/plugin/RevaPlugin.java
https://github.com/Nalen98/GhidraEmu
https://github.com/ZeroDaysBroker/GhidraGPT/tree/main/src/main/java/ghidragpt
https://github.com/bobbylight/RSyntaxTextArea

ghidra stack decomp

https://reverseengineering.stackexchange.com/questions/20905/ghidra-control-flow-graph
https://grant-h.github.io/docs/ghidra/decompiler/files.html
https://github.com/NationalSecurityAgency/ghidra/discussions/5433#discussioncomment-6338755

https://radareorg.github.io/blog/posts/sleigh_disassembler_backend/

https://cgit.git.savannah.gnu.org/cgit/coreutils.git/tree/src

https://github.com/LukeSerne/RuleChef/tree/master
https://github.com/LukeSerne/DecompVis?tab=readme-ov-file#usage

https://github.com/NationalSecurityAgency/ghidra/pull/8161

https://ftp.gnu.org/gnu/gdb/


perplexity

https://www.geeksforgeeks.org/nlp/perplexity-for-llm-evaluation/
https://github.com/coreutils/coreutils
https://github.com/ollama/ollama/issues/2415

https://www.llama.com/docs/model-cards-and-prompt-formats/llama3_1/
https://huggingface.co/blog/4bit-transformers-bitsandbytes
https://medium.com/%40lambdafluxofficial/packing-and-unpacking-weights-in-4-bit-quantization-982c7a04c684
https://huggingface.co/meta-llama/Llama-3.2-1B-Instruct


headless
https://github.com/galoget/ghidra-headless-scripts/tree/main

ruleaction.hh -> definizione di classi che poi sono regole di traduzione da pcode, semplificazioni o funzioni utili (get)
ruleaction.cc -> implementazione delle classi scritte nel .hh, limitate da scope e commenti

blockaction.cc -> regole da flowblock a stutture in C, non c'è più divisione tra vari "stili" -> 
                            CollapseStructure::collapseInternal
                            BlockWhileDo::finalTransform -> from while to for

coreaction.cc -> void ActionDatabase::buildDefaultGroups(void) -> dichiarazione degli stili di azione
                void ActionDatabase::universalAction(Architecture *conf) -> deinizione vari ActionGoup con collegamento delle regole

ActionGroup -> insieme di regole che vengono effettuate in sequenza (generalmente) l'ordine potrebbe cambiare il risultato //Alcuni hanno la proprietà rule_repeatapply -> l'intero gruppo di azioni viene ripetuto finché non vengono più apportate modifiche
ActionPool -> insieme di regole che vengono eseguite in "contemporanea" iterando sui pcode di una funzione

new rule("fase di analisi")

ordine di esecuzione dipende dall'ordine di implementazione, no gerarchie

Vernode -> struttura che implementa una variabile di basso livello o un insieme contiguo di byte, descritta da un Address e una size

action.cc ->
            *ActionDatabase::deriveAction(const string &baseaction, const string &grp) -> funzione per generare una action da eseguire dal basegroup


make decomp_opt -j$(nproc)      # SLEIGH optimized
make decomp_dbg                 # SLEIGH debug
./gradlew buildGhidra           #build




RuleChef

SimplifyLessAndNotEqual:	BOOL_AND(INT_LESSEQUAL(a, b), INT_NOTEQUAL(a, b))       => INT_LESS(a, b)	            -----Da (a <= b && a != b) a (a < b).
SimplifyGreaterAndNotEqual:	BOOL_AND(INT_SLESSEQUAL(a, b), INT_NOTEQUAL(a, b))	    => INT_SLESS(a, b)	            -----Da (a >= b && a != b) a (a > b).
SimplifyOrEqual:	        BOOL_OR(INT_LESS(a, b), INT_EQUAL(a, b))	            => INT_LESSEQUAL(a, b)	        -----Da (a < b || a == b)  a (a <= b).
SimplifyConditionalCopy:	BOOL_NEGATE(INT_EQUAL(a, b))	                        => INT_NOTEQUAL(a, b)	        -----Da !(a == b)          a (a != b).


blocchi -> per il for da while in BlockWhileDo::finalTransform() in block.cc
regole di creazione grafo in blockaction.cc -> apply() -> collapseAll() -> collapseInternal()




flowblock:

=== parent do while ===
0
Basic Block 0 0x0010118d-0x001011d1
0x0010118d:1:	RSP(0x0010118d:1) = RSP(i) + #0xfffffffffffffff8
0x0010118d:2:	*(ram,RSP(0x0010118d:1)) = RBP(i)
0x0010118e:4:	RSP(0x0010118e:4) = RSP(i) + #0xfffffffffffffff0
0x0010118e:5:	*(ram,RSP(0x0010118e:4)) = RBX(i)
0x00101193:f:	u0x00006480(0x00101193:f) = FS_OFFSET(i) + #0x28
0x00101193:10:	u0x00011f00(0x00101193:10) = *(ram,u0x00006480(0x00101193:f))
0x0010119c:12:	u0x00004e80(0x0010119c:12) = RSP(i) + #0xffffffffffffffe0
0x0010119c:14:	*(ram,u0x00004e80(0x0010119c:12)) = u0x00011f00(0x00101193:10)
0x001011af:21:	RSP(0x001011af:21) = RSP(i) + #0xffffffffffffffd0
0x001011af:22:	*(ram,RSP(0x001011af:21)) = #0x1011b4
0x001011af:9a:	u0x10000008:1(0x001011af:9a) = *(ram,RSP(0x001011af:21))
0x001011af:e7:	RDX(0x001011af:e7) = [create] m0x001011af:23(free)
0x001011af:108:	FS_OFFSET(0x001011af:108) = FS_OFFSET(i) [] m0x001011af:23(free)
0x001011af:23:	call l__printf_chk(free)(u0x10000008:1(0x001011af:9a),RCX(i),RDX(i),#0x102004,#0x1)
0x001011b4:24:	u0x00004e80(0x001011b4:24) = RSP(i) + #0xffffffffffffffdc
0x001011c5:28:	RSP(0x001011c5:28) = RSP(i) + #0xffffffffffffffd0
0x001011c5:29:	*(ram,RSP(0x001011c5:28)) = #0x1011ca
0x001011c5:9c:	u0x10000011:1(0x001011c5:9c) = *(ram,RSP(0x001011c5:28))
0x001011c5:e8:	RDX(0x001011c5:e8) = [create] m0x001011c5:2a(free)
0x001011c5:109:	FS_OFFSET(0x001011c5:109) = FS_OFFSET(0x001011af:108) [] m0x001011c5:2a(free)
0x001011c5:2a:	call l__isoc99_scanf(free)(u0x10000011:1(0x001011c5:9c),#0x0,RDX(0x001011af:e7),u0x00004e80(0x001011b4:24),#0x102018)
0x001011ca:2b:	u0x00004e80(0x001011ca:2b) = RSP(i) + #0xffffffffffffffdc
0x001011ca:2c:	u0x00011e80:4(0x001011ca:2c) = *(ram,u0x00004e80(0x001011ca:2b))
0x001011ca:db:	RCX(0x001011ca:db) = ZEXT48(u0x00011e80:4(0x001011ca:2c))
0x001011d1:3b:	u0x00013180:1(0x001011d1:3b) = #0x9:4 < u0x00011e80:4(0x001011ca:2c)
0x001011d1:3c:	goto Block_3:0x00101206 if (u0x00013180:1(0x001011d1:3b) != 0) else Block_1:0x001011d3
Basic Block 1 0x001011d3-0x001011d8
0x001011d3:3d:	RBX(0x001011d3:3d) = #0x0
Basic Block 2 0x001011df-0x00101204
0x001011df:10d:	FS_OFFSET(0x001011df:10d) = FS_OFFSET(0x001011c5:109) ? FS_OFFSET(0x001011ee:10a)
0x001011df:f8:	RBX(0x001011df:f8) = RBX(0x001011d3:3d) ? RBX(0x001011fe:f6)
0x001011df:e3:	RCX(0x001011df:e3) = RCX(0x001011ca:db) ? RCX(0x001011f7:dd)
0x001011df:ed:	EBX(0x001011df:ed) = SUB84(RBX(0x001011df:f8),#0x0:4)
0x001011ee:44:	RSP(0x001011ee:44) = RSP(i) + #0xffffffffffffffd0
0x001011ee:45:	*(ram,RSP(0x001011ee:44)) = #0x1011f3
0x001011ee:9e:	u0x1000001a:1(0x001011ee:9e) = *(ram,RSP(0x001011ee:44))
0x001011ee:e9:	RDX(0x001011ee:e9) = [create] m0x001011ee:46(free)
0x001011ee:10a:	FS_OFFSET(0x001011ee:10a) = FS_OFFSET(0x001011df:10d) [] m0x001011ee:46(free)
0x001011ee:46:	call l__printf_chk(free)(u0x1000001a:1(0x001011ee:9e),RCX(0x001011df:e3),RBX(0x001011df:f8),#0x102020,#0x1)
0x001011f3:47:	u0x00004e80(0x001011f3:47) = RSP(i) + #0xffffffffffffffdc
0x001011f3:48:	u0x00011e80:4(0x001011f3:48) = *(ram,u0x00004e80(0x001011f3:47))
0x001011f7:141:	u0x00004780:4(0x001011f7:141) = u0x00011e80:4(0x001011f3:48) + #0x1:4
0x001011f7:dd:	RCX(0x001011f7:dd) = ZEXT48(u0x00004780:4(0x001011f7:141))
0x001011fa:4e:	u0x00004e80(0x001011fa:4e) = RSP(i) + #0xffffffffffffffdc
0x001011fa:50:	*(ram,u0x00004e80(0x001011fa:4e)) = u0x00004780:4(0x001011f7:141)
0x001011fe:53:	EBX(0x001011fe:53) = EBX(0x001011df:ed) + #0x1:4
0x001011fe:f6:	RBX(0x001011fe:f6) = ZEXT48(EBX(0x001011fe:53))
0x00101204:66:	u0x00012f80:1(0x00101204:66) = u0x00004780:4(0x001011f7:141) < #0xa:4
0x00101204:67:	goto Block_2:0x001011df if (u0x00012f80:1(0x00101204:66) != 0) else Block_3:0x00101206
Basic Block 3 0x00101206-0x00101214
0x00101206:10c:	FS_OFFSET(0x00101206:10c) = FS_OFFSET(0x001011c5:109) ? FS_OFFSET(0x001011ee:10a)
0x00101206:eb:	RDX(0x00101206:eb) = RDX(0x001011c5:e8) ? RDX(0x001011ee:e9)
0x00101206:e2:	RCX(0x00101206:e2) = RCX(0x001011ca:db) ? RCX(0x001011f7:dd)
0x00101206:68:	u0x00004e80(0x00101206:68) = RSP(i) + #0xffffffffffffffe0
0x00101206:69:	u0x00011f00(0x00101206:69) = *(ram,u0x00004e80(0x00101206:68))
0x0010120b:6b:	u0x00006480(0x0010120b:6b) = FS_OFFSET(0x00101206:10c) + #0x28
0x0010120b:70:	u0x00011f00(0x0010120b:70) = *(ram,u0x00006480(0x0010120b:6b))
0x0010120b:73:	ZF(0x0010120b:73) = u0x00011f00(0x00101206:69) != u0x00011f00(0x0010120b:70)
0x00101214:79:	goto Block_4:0x00101222 if (ZF(0x0010120b:73) != 0) else Block_5:0x00101216
Basic Block 4 0x00101222-0x00101222
0x00101222:8f:	RSP(0x00101222:8f) = RSP(i) + #0xffffffffffffffd0
0x00101222:90:	*(ram,RSP(0x00101222:8f)) = #0x101227
0x00101222:a0:	u0x10000023:1(0x00101222:a0) = *(ram,RSP(0x00101222:8f))
0x00101222:91:	call l__stack_chk_fail(free)(u0x10000023:1(0x00101222:a0),RCX(0x00101206:e2),RDX(0x00101206:eb),#0x0,#0x0)
0x00101222:93:	return(#0x1:4)
Basic Block 5 0x00101216-0x00101221
0x00101221:ca:	EAX(0x00101221:ca) = #0x0:4
0x00101221:8e:	return(#0x0) EAX(0x00101221:ca)

=====================
{
  int iVar1;
  long in_FS_OFFSET;
  int a;
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  __printf_chk(1,"=== TestWhiles ===\n");
                    /* Unresolved local var: int i@[???] */
  __isoc99_scanf(&DAT_00102018,&a);
  if (a < 10) {
    iVar1 = 0;
    do {
      __printf_chk(1,"While semplice: i = %d, a = %d\n",iVar1);
      a = a + 1;
      iVar1 = iVar1 + 1;
    } while (a < 10);
  }
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return 0;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail();
}

=== newbl whiledo parent ===
0
Basic Block 0 0x0010114d-0x00101158
0x0010114d:1:	RSP(0x0010114d:1) = RSP(i) + #0xfffffffffffffff8
0x0010114d:2:	*(ram,RSP(0x0010114d:1)) = RBP(i)
0x0010114e:4:	RSP(0x0010114e:4) = RSP(i) + #0xfffffffffffffff0
0x0010114e:5:	*(ram,RSP(0x0010114e:4)) = RBX(i)
0x00101153:14a:	EBX(0x00101153:14a) = #0x0:4
Basic Block 1 0x0010115f-0x00101165
0x0010115f:147:	EBX(0x0010115f:147) = EBX(0x00101153:14a) ? EBX(0x0010115f:13) ? EBX(0x0010115f:13)
0x0010115f:13:	EBX(0x0010115f:13) = EBX(0x0010115f:147) + #0x1:4
0x00101162:20:	ZF(0x00101162:20) = EBX(0x0010115f:13) == #0xa:4
0x00101165:25:	goto Block_3:0x00101167 if (ZF(0x00101162:20) == 0) else Block_2:0x00101199
Basic Block 2 0x00101199-0x001011a4
0x001011a4:108:	EAX(0x001011a4:108) = #0x0:4
0x001011a4:b0:	return(#0x0) EAX(0x001011a4:108)
If block 3
Basic Block 3 0x00101167-0x00101181
0x00101171:14c:	u0x10000039:4(0x00101171:14c) = EBX(0x0010115f:13) / #0x3:4
0x0010117a:154:	u0x1000003d:4(0x0010117a:154) = EBX(0x0010115f:13) s>> #0x1f:4
0x00101171:32:	EAX(0x00101171:32) = u0x10000039:4(0x00101171:14c) + u0x1000003d:4(0x0010117a:154)
0x00101177:59:	EDX(0x00101177:59) = EBX(0x0010115f:13) s>> #0x1f:4
0x0010117a:152:	u0x10000035:4(0x0010117a:152) = EDX(0x00101177:59) * #0xffffffff:4
0x0010117a:7c:	EAX(0x0010117a:7c) = EAX(0x00101171:32) + u0x10000035:4(0x0010117a:152)
0x0010117c:15e:	u0x10000059:4(0x0010117c:15e) = EAX(0x0010117a:7c) * #0x3:4
0x0010117f:8d:	ZF(0x0010117f:8d) = EBX(0x0010115f:13) == u0x10000059:4(0x0010117c:15e)
0x00101181:92:	goto Block_4:0x00101183 if (ZF(0x0010117f:8d) == 0) else Block_1:0x0010115f
Basic Block 4 0x00101183-0x00101197
0x00101183:11f:	RDX(0x00101183:11f) = ZEXT48(EBX(0x0010115f:13))
0x00101192:98:	RSP(0x00101192:98) = RSP(i) + #0xffffffffffffffe0
0x00101192:99:	*(ram,RSP(0x00101192:98)) = #0x101197
0x00101192:b4:	u0x10000008:1(0x00101192:b4) = *(ram,RSP(0x00101192:98))
0x00101192:9a:	call l__printf_chk(free)(u0x10000008:1(0x00101192:b4),RDX(0x00101183:11f),#0x102004,#0x1)
0x00101197:9b:	goto Block_1:0x0010115f

=====================
{
  int iVar1;
  
                    /* Unresolved local var: int i@[???] */
  iVar1 = 0;
  while (iVar1 = iVar1 + 1, iVar1 != 10) {
    if (iVar1 != (iVar1 / 3) * 3) {
      __printf_chk(1,"For con continue: i = %d\n",iVar1);
    }
  }
  return 0;
}


=== newbl whiledo parent ===
0
Basic Block 0 0x0010114d-0x00101173
0x0010114d:1:	RSP(0x0010114d:1) = RSP(i) + #0xfffffffffffffff8
0x0010114d:2:	*(ram,RSP(0x0010114d:1)) = R12(i)
0x0010114f:4:	RSP(0x0010114f:4) = RSP(i) + #0xfffffffffffffff0
0x0010114f:5:	*(ram,RSP(0x0010114f:4)) = RBP(i)
0x00101150:7:	RSP(0x00101150:7) = RSP(i) + #0xffffffffffffffe8
0x00101150:8:	*(ram,RSP(0x00101150:7)) = RBX(i)
0x00101162:c:	RSP(0x00101162:c) = RSP(i) + #0xffffffffffffffe0
0x00101162:d:	*(ram,RSP(0x00101162:c)) = #0x101167
0x00101162:b8:	u0x10000008:1(0x00101162:b8) = *(ram,RSP(0x00101162:c))
0x00101162:11e:	RDX(0x00101162:11e) = [create] m0x00101162:e(free)
0x00101162:e:	call l__printf_chk(free)(u0x10000008:1(0x00101162:b8),RDX(i),#0x102004,#0x1)
0x00101167:15d:	EBX(0x00101167:15d) = #0x0:4
Basic Block 1 0x0010117a-0x00101180
0x0010117a:15a:	EBX(0x0010117a:15a) = EBX(0x00101167:15d) ? EBX(0x0010117a:14) ? EBX(0x0010117a:14)
0x0010117a:121:	RDX(0x0010117a:121) = RDX(0x00101162:11e) ? RDX(0x001011a4:11b) ? RDX(0x001011bf:120)
0x0010117a:14:	EBX(0x0010117a:14) = EBX(0x0010117a:15a) + #0x1:4
0x0010117d:21:	ZF(0x0010117d:21) = EBX(0x0010117a:14) == #0xa:4
0x00101180:26:	goto Block_3:0x00101182 if (ZF(0x0010117d:21) == 0) else Block_2:0x001011c6
Basic Block 2 0x001011c6-0x001011cf
0x001011cf:104:	EAX(0x001011cf:104) = #0x0:4
0x001011cf:b2:	return(#0x0) EAX(0x001011cf:104)
If block 3
Basic Block 3 0x00101182-0x001011ae
0x0010118f:2a:	RSP(0x0010118f:2a) = RSP(i) + #0xffffffffffffffe0
0x0010118f:2b:	*(ram,RSP(0x0010118f:2a)) = #0x101194
0x0010118f:ba:	u0x10000011:1(0x0010118f:ba) = *(ram,RSP(0x0010118f:2a))
0x0010118f:2c:	call l__printf_chk(free)(u0x10000011:1(0x0010118f:ba),RDX(0x0010117a:121),#0x102004,#0x1)
0x0010119e:160:	u0x1000005b:4(0x0010119e:160) = EBX(0x0010117a:14) / #0x3:4
0x001011a7:166:	u0x1000005f:4(0x001011a7:166) = EBX(0x0010117a:14) s>> #0x1f:4
0x0010119e:39:	EAX(0x0010119e:39) = u0x1000005b:4(0x0010119e:160) + u0x1000005f:4(0x001011a7:166)
0x001011a4:60:	EDX(0x001011a4:60) = EBX(0x0010117a:14) s>> #0x1f:4
0x001011a4:11b:	RDX(0x001011a4:11b) = ZEXT48(EDX(0x001011a4:60))
0x001011a7:164:	u0x10000057:4(0x001011a7:164) = EDX(0x001011a4:60) * #0xffffffff:4
0x001011a7:83:	EAX(0x001011a7:83) = EAX(0x0010119e:39) + u0x10000057:4(0x001011a7:164)
0x001011a9:170:	u0x1000007b:4(0x001011a9:170) = EAX(0x001011a7:83) * #0x3:4
0x001011ac:94:	ZF(0x001011ac:94) = EBX(0x0010117a:14) == u0x1000007b:4(0x001011a9:170)
0x001011ae:99:	goto Block_4:0x001011b0 if (ZF(0x001011ac:94) == 0) else Block_1:0x0010117a
Basic Block 4 0x001011b0-0x001011c4
0x001011b0:11d:	RDX(0x001011b0:11d) = ZEXT48(EBX(0x0010117a:14))
0x001011bf:9f:	RSP(0x001011bf:9f) = RSP(i) + #0xffffffffffffffe0
0x001011bf:a0:	*(ram,RSP(0x001011bf:9f)) = #0x1011c4
0x001011bf:bc:	u0x1000001a:1(0x001011bf:bc) = *(ram,RSP(0x001011bf:9f))
0x001011bf:120:	RDX(0x001011bf:120) = [create] m0x001011bf:a1(free)
0x001011bf:a1:	call l__printf_chk(free)(u0x1000001a:1(0x001011bf:bc),RDX(0x001011b0:11d),#0x102010,#0x1)
0x001011c4:a2:	goto Block_1:0x0010117a

{
  int iVar1;
  
                    /* Unresolved local var: int i@[???] */
  __printf_chk(1,"altroprintf");
  iVar1 = 0;
  while (iVar1 = iVar1 + 1, iVar1 != 10) {                    //block1
    __printf_chk(1,"altroprintf");
    if (iVar1 != (iVar1 / 3) * 3) {
      __printf_chk(1,"For con continue: i = %d\n",iVar1);
    }
  }
  return 0;
}


Basic Block 4 0x001011b1-0x001011bb
0x001011b6:33:	RSP(0x001011b6:33) = RSP(i) + #0xffffffffffffffe0
0x001011b6:34:	*(ram,RSP(0x001011b6:33)) = #0x1011bb
0x001011b6:6d:	u0x10000023:1(0x001011b6:6d) = *(ram,RSP(0x001011b6:33))
0x001011b6:35:	call jputchar(free)(#0x33:4,u0x10000023:1(0x001011b6:6d))           //3
0x001011bb:36:	goto Block_5:0x001011db
Condition block(||) 0
Basic Block 0 0x0010118d-0x001011a9
0x0010118d:1:	RSP(0x0010118d:1) = RSP(i) + #0xfffffffffffffff8
0x0010118d:2:	*(ram,RSP(0x0010118d:1)) = RBP(i)
0x00101195:d:	u0x00004780(0x00101195:d) = RSP(i) + #0xfffffffffffffff4
0x00101195:f:	*(ram,u0x00004780(0x00101195:d)) = EDI(i)
0x00101198:10:	u0x00004780(0x00101198:10) = RSP(i) + #0xfffffffffffffff0
0x00101198:12:	*(ram,u0x00004780(0x00101198:10)) = ESI(i)
0x001011a0:14:	RSP(0x001011a0:14) = RSP(i) + #0xffffffffffffffe0
0x001011a0:15:	*(ram,RSP(0x001011a0:14)) = #0x1011a5
0x001011a0:67:	u0x10000008:1(0x001011a0:67) = *(ram,RSP(0x001011a0:14))
0x001011a0:16:	call jputchar(free)(#0x31:4,u0x10000008:1(0x001011a0:67))             //1
0x001011a5:17:	u0x00004780(0x001011a5:17) = RSP(i) + #0xfffffffffffffff4
0x001011a5:18:	u0x00011e80:4(0x001011a5:18) = *(ram,u0x00004780(0x001011a5:17))
0x001011a5:1e:	ZF(0x001011a5:1e) = u0x00011e80:4(0x001011a5:18) == #0x1:4
0x001011a9:23:	goto Block_2:0x001011bd if (ZF(0x001011a5:1e) != 0) else Block_1:0x001011ab
Basic Block 1 0x001011ab-0x001011af
0x001011ab:24:	u0x00004780(0x001011ab:24) = RSP(i) + #0xfffffffffffffff0
0x001011ab:25:	u0x00011e80:4(0x001011ab:25) = *(ram,u0x00004780(0x001011ab:24))
0x001011ab:2b:	ZF(0x001011ab:2b) = u0x00011e80:4(0x001011ab:25) != #0x2:4
0x001011af:31:	goto Block_2:0x001011bd if (ZF(0x001011ab:2b) != 0) else Block_4:0x001011b1
List block 5
Basic Block 5 0x001011db-0x001011e0
0x001011e0:38:	RSP(0x001011e0:38) = RSP(i) + #0xffffffffffffffe0
0x001011e0:39:	*(ram,RSP(0x001011e0:38)) = #0x1011e5
0x001011e0:6f:	u0x1000002c:1(0x001011e0:6f) = *(ram,RSP(0x001011e0:38))
0x001011e0:3a:	call jputchar(free)(#0x35:4,u0x1000002c:1(0x001011e0:6f))             //5
Basic Block 6 0x001011e5-0x001011f1
0x001011ea:3c:	RSP(0x001011ea:3c) = RSP(i) + #0xffffffffffffffe0
0x001011ea:3d:	*(ram,RSP(0x001011ea:3c)) = #0x1011ef
0x001011ea:71:	u0x10000035:1(0x001011ea:71) = *(ram,RSP(0x001011ea:3c))
0x001011ea:3e:	call jputchar(free)(#0x36:4,u0x10000035:1(0x001011ea:71))           //6
0x001011f1:44:	return(#0x0)
If block 2
Basic Block 2 0x001011bd-0x001011cd
0x001011c2:46:	RSP(0x001011c2:46) = RSP(i) + #0xffffffffffffffe0
0x001011c2:47:	*(ram,RSP(0x001011c2:46)) = #0x1011c7
0x001011c2:69:	u0x10000011:1(0x001011c2:69) = *(ram,RSP(0x001011c2:46))
0x001011c2:48:	call jputchar(free)(#0x32:4,u0x10000011:1(0x001011c2:69))               //2
0x001011c7:49:	u0x00004780(0x001011c7:49) = RSP(i) + #0xfffffffffffffff4
0x001011c7:4a:	u0x00011e80:4(0x001011c7:4a) = *(ram,u0x00004780(0x001011c7:49))
0x001011ca:4d:	u0x00004780(0x001011ca:4d) = RSP(i) + #0xfffffffffffffff0
0x001011ca:4e:	u0x00006a00:4(0x001011ca:4e) = *(ram,u0x00004780(0x001011ca:4d))
0x001011ca:54:	ZF(0x001011ca:54) = u0x00011e80:4(0x001011c7:4a) == u0x00006a00:4(0x001011ca:4e)
0x001011cd:59:	goto Block_3:0x001011cf if (ZF(0x001011ca:54) == 0) else Block_5:0x001011db
Basic Block 3 0x001011cf-0x001011d9
0x001011d4:5b:	RSP(0x001011d4:5b) = RSP(i) + #0xffffffffffffffe0
0x001011d4:5c:	*(ram,RSP(0x001011d4:5b)) = #0x1011d9
0x001011d4:6b:	u0x1000001a:1(0x001011d4:6b) = *(ram,RSP(0x001011d4:5b))
0x001011d4:5d:	call jputchar(free)(#0x34:4,u0x1000001a:1(0x001011d4:6b))             //4
0x001011d9:5e:	goto Block_6:0x001011e5

{
  int a2_local;                       //block0
  int a1_local;                       //block0
  putchar(L'1');                      //block0
  if ((a1 == 1) || (a2 != 2)) {       //block0 || //block1
    putchar(L'2');                    //block2
    if (a1 != a2) {                   //block2
      putchar(L'4');                  //block3
      goto LAB_001011e5;              //block3
    }
  }
  else {
    putchar(L'3');                    //block4
  }
  putchar(L'5');                      //block5
LAB_001011e5:                         //block6
  putchar(L'6');                      //block6
  return;                             //block6
}
